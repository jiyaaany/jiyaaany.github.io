{"componentChunkName":"component---src-templates-blog-template-js","path":"/react-router-tips/","result":{"data":{"cur":{"id":"20ab402e-3753-5266-9ccd-f088628f4bb1","html":"<h1 id=\"시작하며\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\" aria-label=\"시작하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작하며</h1>\n<p>토이프로젝트를 진행하며 <a href=\"https://reactrouter.com/\">React Router</a> 에 대해 알게된 점을 기록해두자 !</p>\n<h1 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h1>\n<h2 id=\"code-classlanguage-textexactcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textexactcode\" aria-label=\"code classlanguage textexactcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">exact</code></h2>\n<p><code class=\"language-text\">exact</code> 키워드는 정확히 일치 되었을 때만 지정된 컴포넌트를 보여주는 속성이다. 만약 <code class=\"language-text\">exact</code> 키워드 없이 라우터를 지정한다면 <code class=\"language-text\">{URL}/</code>, <code class=\"language-text\">{URL}/1</code> 모두 같은 컴포넌트를 렌더링한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>Route exact path<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token constant\">PATH</span><span class=\"token punctuation\">}</span> component<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token constant\">COMPONENT</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<h3 id=\"code-classlanguage-textltswtichcode와의-차이\" style=\"position:relative;\"><a href=\"#code-classlanguage-textltswtichcode%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"code classlanguage textltswtichcode와의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">&lt;Swtich></code>와의 차이</h3>\n<p><code class=\"language-text\">exact</code> 키워드만으로는 에러가 발생했을 때의 처리가 어렵다. 아래와 같은 라우터가 있을 때 지정되지 않은 url에 접근할 경우 <code class=\"language-text\">Error404</code> 컴포넌트를 렌더링 하지 않는다는 것을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>Router<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>Route exact path<span class=\"token operator\">=</span><span class=\"token string\">\"/\"</span> component<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>Foo<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>Route path<span class=\"token operator\">=</span><span class=\"token string\">\"/bar\"</span> component<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>Bar<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>Route component<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>Error404<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Router<span class=\"token operator\">></span></code></pre></div>\n<p>이 문제를 해결하기 위한 방법으로 나온 것이 <code class=\"language-text\">&lt;Switch></code>이다. <code class=\"language-text\">&lt;Swtich></code>는 첫번째로 매칭되는 <code class=\"language-text\">path</code>를 가진 컴포넌트를 렌더링 시킨다. 이것이 <code class=\"language-text\">exact</code>와 다른점이며, 지정되지 않은 url에 접근 시 <code class=\"language-text\">Error404</code> 컴포넌트를 렌더링 시킨다는 것을 확인할 수 있다.</p>\n<h2 id=\"code-classlanguage-textstrictcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textstrictcode\" aria-label=\"code classlanguage textstrictcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">strict</code></h2>\n<p><code class=\"language-text\">strict</code> 키워드는 trailing slash가 있을 경우에만 일치한다.. 추가로 슬래시 뒤에 URL이 있는 경우엔 영향을 미치지 않는다.</p>\n<table>\n<thead>\n<tr>\n<th>path</th>\n<th>location.path</th>\n<th>match</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">no</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one/</code></td>\n<td><code class=\"language-text\">yes</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one/two</code></td>\n<td><code class=\"language-text\">yes</code></td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">exact</code> 키워드와 함께 사용할 경우 이렇게 작동한다.</p>\n<table>\n<thead>\n<tr>\n<th>path</th>\n<th>location.path</th>\n<th>match</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">yes</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one/</code></td>\n<td><code class=\"language-text\">no</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one/two</code></td>\n<td><code class=\"language-text\">no</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"code-classlanguage-textsensitivecode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textsensitivecode\" aria-label=\"code classlanguage textsensitivecode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">sensitive</code></h2>\n<p><code class=\"language-text\">sensitive</code> 키워드는 <code class=\"language-text\">case</code>를 검사한다.</p>\n<table>\n<thead>\n<tr>\n<th>path</th>\n<th>location.path</th>\n<th>sensitive</th>\n<th>match</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">yes</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">/One</code></td>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">no</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">/One</code></td>\n<td><code class=\"language-text\">/one</code></td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">yes</code></td>\n</tr>\n</tbody>\n</table>","excerpt":"시작하며 토이프로젝트를 진행하며 React Router 에 대해 알게된 점을 기록해두자 ! 정리   키워드는 정확히 일치 되었을 때만 지정된 컴포넌트를 보여주는 속성이다. 만약  키워드 없이 라우터를 지정한다면 ,  모두 같은 컴포넌트를 렌더링한다. 와의 차이  키워드만으로는 에러가 발생했을 때의 처리가 어렵다. 아래와 같은 라우터가 있을 때 지정되지 않은 url에 접근할 경우  컴포넌트를 렌더링 하지 않는다는 것을 확인할 수 있다. 이 문제를 해결하기 위한 방법으로 나온 것이 이다. 는 첫번째로 매칭되는 를 가진 컴포넌트를 렌더링 시킨다. 이것이 와 다른점이며, 지정되지 않은 url에 접근 시  컴포넌트를 렌더링 시킨다는 것을 확인할 수 있다.   키워드는 trailing slash가 있을 경우에만 일치한다.. 추가로 슬래시 뒤에 URL이 있는 경우엔 영향을 미치지 않는다. path location.path match           키워드와 함께 사용할 경우 이렇게 작동한다.…","frontmatter":{"date":"November 10, 2021","title":"사용하면서 배우는 React Router","categories":"TIL","author":"지걸","emoji":"📚"},"fields":{"slug":"/react-router-tips/"}},"next":{"id":"7974cde1-462d-573c-95fa-1747df3ed755","html":"<h1 id=\"시작하며\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\" aria-label=\"시작하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작하며</h1>\n<p><a href=\"https://github.com/k-roffle/knitting-frontend\">니팅</a> 프로젝트를 진행하며 recoil이라는 상태 관리 라이브러리르 처음 사용해보았다. 기존에 구성이 다 잡혀있어서 새로운 상태 추가, 기존에 있던 상태 사용 등의 것들만 해보았는데 프로젝트에서 recoil을 사용하는 방법과 atom, selector에 대한 개념적인 부분이 부족하다고 생각하여 <a href=\"https://recoiljs.org/ko/\">공식문서</a> 를 읽어보았다.</p>\n<h1 id=\"recoil\" style=\"position:relative;\"><a href=\"#recoil\" aria-label=\"recoil permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recoil</h1>\n<p>Recoil은 React를 위한 상태관리 라이브러리이다.</p>\n<ul>\n<li>작고 React스러운</li>\n</ul>\n<p>Recoil은 React처럼 작동하고 생각합니다. 앱에 추가하여 빠르고 유연한 공유되는 상태를 사용해보세요.</p>\n<ul>\n<li>데이터 흐름 그래프</li>\n</ul>\n<p>파생 데이터와 비동기 쿼리는 순수 함수와 효율적인 구독으로 관리됩니다.</p>\n<ul>\n<li>교차하는 앱 관찰</li>\n</ul>\n<p>코드 분할을 손상시키지 않고 앱 전체의 모든 상태 변경을 관찰하여 지속성, 라우팅, 시간 이동 디버깅 또는 실행 취소를 구현합니다.</p>\n<h2 id=\"주요-개념\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%85%90\" aria-label=\"주요 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주요 개념</h2>\n<h3 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h3>\n<p>Recoil을 사용하면 atoms(공유 상태)에서 selectors(순수 함수)를 거쳐 React 컴포넌트로 내려가는 <strong>data-flow graph</strong>를 만들 수 있다. Atoms는 컴포넌트가 구독할 수 있는 상태의 단위다. Selectors는 atoms 상태값을 동기 또는 비동기 방식을 통해 변환한다.</p>\n<h3 id=\"atoms\" style=\"position:relative;\"><a href=\"#atoms\" aria-label=\"atoms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Atoms</h3>\n<p>Atoms는 상태의 단위이며, 업데이트와 구독이 가능하다. atom이 업데이트되면 각각의 구독된 컴포넌트는 새로운 값을 반영하여 다시 렌더링 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fontSizeState <span class=\"token operator\">=</span> <span class=\"token function\">atom</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> <span class=\"token string\">'fontSizeState'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">default</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Atom는 디버깅, 지속성 및 모든 atoms의 map을 볼 수 있는 특정 고급 API에 사용되는 고유한 키가 필요하다. 키 값은 전역적으로 고유하도록 해야한다. React 컴포넌트의 상태처럼 기본값도 가진다.\n컴포넌트에서 atom을 읽고 쓰려면 <code class=\"language-text\">useRecoilState</code>라는 훅을 사용한다. <code class=\"language-text\">useState</code>와 비슷하지만 컴포넌트 간에 공유될 수 있다는 차이가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>fontSize<span class=\"token punctuation\">,</span> setFontSize<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useRecoilState</span><span class=\"token punctuation\">(</span>fontSizeState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4 id=\"추가설명\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EC%84%A4%EB%AA%85\" aria-label=\"추가설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가설명</h4>\n<p><code class=\"language-text\">atom()</code>함수는 쓰기 가능한 <code class=\"language-text\">RecoilState</code> 객체를 반환한다. <a href=\"https://recoiljs.org/ko/docs/api-reference/core/atom/\">자세한 설명</a><br>\n<strong>atom과 상호작용하기 위해 자주 사용되는 Hooks</strong></p>\n<ul>\n<li><code class=\"language-text\">useRecoilState()</code>: atom을 읽고 쓰려고 할 때 사용하는 Hook</li>\n<li><code class=\"language-text\">useRecoilValue()</code>: atom을 읽기만 할 때 사용하는 Hook</li>\n<li><code class=\"language-text\">useSetRecoilState()</code>: atom에 쓰려고만 할 때 사용하는 Hook</li>\n<li><code class=\"language-text\">useResetRecoilState()</code>: atom을 초기값으로 초기화할 때 사용하는 Hook</li>\n</ul>\n<h3 id=\"selectors\" style=\"position:relative;\"><a href=\"#selectors\" aria-label=\"selectors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Selectors</h3>\n<p><strong>Selector</strong>는 atoms나 다른 selectors를 입력으로 받아들이는 순수 함수(pure function)다. 상위의 atoms, selectors가 업데이트되면 하위의 selector 함수도 다시 실행된다. 컴포넌트들은 selectors를 atoms처럼 구독할 수 있으며 selectors가 변경되면 컴포넌트들도 다시 렌더링 된다.<br>\nSelectors는 상태를 기반으로 파생되는 데이터를 계산하는데에 사용된다. 최소한의 상태 집합만 atoms에 저장하고 다른 파생 데이터는 selectors에 명시된 함수를 통해 계산함으로써 쓸모없는 상태의 보존을 방지한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fontSizeLabelState <span class=\"token operator\">=</span> <span class=\"token function\">selector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> <span class=\"token string\">'fontSizeLabelState'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">get</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> get <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> fontSize <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>fontSizeState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> unit <span class=\"token operator\">=</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fontSize<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>unit<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">get</code>속성은 계산될 함수다. 전달되는 <code class=\"language-text\">get</code> 인자를 통해 atoms와 다른 selectors에 접근할 수 있다. 다른 것들에 접근하면 종속 관계가 생성되므로, 다른 것들이 업데이트되면 이 함수도 다시 실행된다.<br>\nSelectors는 <code class=\"language-text\">useRecoilValue()</code>를 사용해 읽을 수 있다. <code class=\"language-text\">useRecoilValue()</code>는 하나의 atom이나 selector를 인자로 받아 대응하는 값을 반환한다.</p>\n<h2 id=\"recoil-시작하기\" style=\"position:relative;\"><a href=\"#recoil-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"recoil 시작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recoil 시작하기</h2>\n<h3 id=\"recoilroot\" style=\"position:relative;\"><a href=\"#recoilroot\" aria-label=\"recoilroot permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RecoilRoot</h3>\n<p>recoil 상태를 사용하는 컴포넌트는 부모 트리 어딘가에 나타나는 <code class=\"language-text\">RecoilRoot</code>가 필요하다. 루트 컴포넌트가 가장 좋은 장소다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>공식문서에선 <a href=\"https://recoiljs.org/ko/docs/guides/asynchronous-data-queries\">비동기 데이터 쿼리</a> 나 <a href=\"https://recoiljs.org/ko/docs/guides/testing\">테스팅</a> 방법에 대해서도 가이드해주고 있다. 실제 프로젝트에서 사용 시 문서를 참고하면 좋을 것 같다.</p>","frontmatter":{"date":"October 27, 2021","title":"Recoil","categories":"TIL","author":"지걸","emoji":"💻"},"fields":{"slug":"/recoil/"}},"prev":{"id":"3fb21fe8-7f12-5c16-8599-7fb9337b29ef","html":"<p>#시작하며\n친구들과 프로젝트를 진행하면서 <a href=\"https://react-query.tanstack.com/\">React Query</a> 를 사용하게 되었습니다. 간단히 찾아보니 api등의 비동기 통신을 도와주는 라이브러리 라는 것으로 파악했습니다. 기존에도 <code class=\"language-text\">react</code>를 사용하여 프로젝트를 진행할 때 여러 비동기 통신을 해보았지만 단순 <code class=\"language-text\">axios</code>를 통해 통신하는 것만 경험해보았습니다. <code class=\"language-text\">React Query</code>를 살펴보며 왜 써야하는지? <code class=\"language-text\">axios</code>만 사용했을 때와 다른 점은 무엇인지 알아봅시다.</p>\n<blockquote>\n<p><strong>22.02.24 추가</strong><br>\n우아한 테크 세미나에서 React Query를 소개한 내용이 있어 추가 정리합니다.</p>\n</blockquote>\n<h1 id=\"code-classlanguage-textreact-querycode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textreact-querycode\" aria-label=\"code classlanguage textreact querycode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">React Query</code></h1>\n<p><code class=\"language-text\">React Query</code>는 웹 서비스 요청에 의한 데이터를 관리하는데 도움을 주는 라이브러리 입니다. 실제 요청은 여전히 <code class=\"language-text\">fetch</code> 또는 <code class=\"language-text\">axios</code>를 사용하여 하고, <code class=\"language-text\">React Query</code>는 라이프 사이클의 적절한 시간에 요청하는 코드를 호출합니다. 또한 요청에 의한 데이터를 저장해두고, 필요한 때 데이터를 제공합니다.<br>\n이 외에도 <code class=\"language-text\">React Query</code>는 캐싱 및 재요청 같은 수많은 기능을 제공하지만, 가장 큰 장점은 코드를 정리화한다는 것입니다.</p>\n<h2 id=\"사용법\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용법</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm i react-query\n# or\nyarn add react-query</code></pre></div>\n<p>데이터를 가져와야하는 컴포넌트 상위에 <code class=\"language-text\">QueryClientProvider</code> 컴포넌트가 필요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> QueryClient<span class=\"token punctuation\">,</span> QueryClientProvider <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-query'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">QueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n<span class=\"token operator\">&lt;</span>QueryClientProvider client<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>queryClient<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>QueryClientProvider<span class=\"token operator\">></span></code></pre></div>\n<h3 id=\"code-classlanguage-textreact-querycode-사용하기\" style=\"position:relative;\"><a href=\"#code-classlanguage-textreact-querycode-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"code classlanguage textreact querycode 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">React Query</code> 사용하기</h3>\n<p><code class=\"language-text\">useQuery</code> 훅을 사용하여 데이터를 가져올 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">BlaBla</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  text<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> status<span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">,</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useQuery</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>BlaBla<span class=\"token punctuation\">,</span> Error<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'blabla'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  getBlaBla\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">useQuery</code>는 첫 번째 인자로 고유한 키 값을 갖고, 두번째 인자로 실제 데이터를 요청하는 함수를 받습니다. 그리고 제네릭 타입 파라미터로 데이터와 에러의 타입을 받습니다.</p>\n<ul>\n<li><code class=\"language-text\">status</code>: 데이터를 가져오는 상태를 의미합니다. (<code class=\"language-text\">\"idle\"</code>, <code class=\"language-text\">\"error\"</code>, <code class=\"language-text\">\"loading\"</code>, <code class=\"language-text\">\"success\"</code> )</li>\n<li><code class=\"language-text\">error</code>: 데이터를 가져오는 중 에러가 발생한 경우 에러 객체를 포함합니다.</li>\n<li><code class=\"language-text\">data</code>: 성공적으로 가져온 데이터를 포함합니다.</li>\n</ul>\n<h4 id=\"code-classlanguage-textusequerycode-option\" style=\"position:relative;\"><a href=\"#code-classlanguage-textusequerycode-option\" aria-label=\"code classlanguage textusequerycode option permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">useQuery</code> Option</h4>\n<ul>\n<li>enabled: 자동으로 query를 실행시킬지 말지 여부 (컴포넌트 마운트 시 자동 실행 방지)</li>\n<li>select: 성공 시 가져온 data를 가공</li>\n</ul>\n<h4 id=\"순차적으로-실행하고-싶은-api를-호출해야-할-때\" style=\"position:relative;\"><a href=\"#%EC%88%9C%EC%B0%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%80-api%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%B4%EC%95%BC-%ED%95%A0-%EB%95%8C\" aria-label=\"순차적으로 실행하고 싶은 api를 호출해야 할 때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순차적으로 실행하고 싶은 API를 호출해야 할 때</h4>\n<ul>\n<li>enabled 옵션을 <code class=\"language-text\">false</code>로 두고 refetch 함수를 정의한다.</li>\n<li>enabled 옵션에 이 전에 실행했던 API의 응답 값 또는 필드를 넣는다.</li>\n</ul>\n<h4 id=\"code-classlanguage-textusequerycode-응답-값을-사용해-action을-생성해야-하는-경우\" style=\"position:relative;\"><a href=\"#code-classlanguage-textusequerycode-%EC%9D%91%EB%8B%B5-%EA%B0%92%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-action%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"code classlanguage textusequerycode 응답 값을 사용해 action을 생성해야 하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">useQuery</code> 응답 값을 사용해 action을 생성해야 하는 경우</h4>\n<ul>\n<li><code class=\"language-text\">useQuery</code> onSuccess에 정의한다.</li>\n</ul>\n<h1 id=\"mutation\" style=\"position:relative;\"><a href=\"#mutation\" aria-label=\"mutation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mutation</h1>\n<blockquote>\n<p>Optimistic update ?<br>\n<code class=\"language-text\">useMutation</code>의 <code class=\"language-text\">onMutate</code>의 경우 Optimistic update 적용 할 때 유용하다.<br>\nOptimistic update는 API 호출을 해야하는 경우에, 호출 전 API가 동작할 것이라고 예상하고 미리 UI를 업데이트 해놓는 것이다. (API 호출 실패 시 다시 롤백)</p>\n</blockquote>\n<p>#<code class=\"language-text\">React Query</code>의 장점</p>\n<ul>\n<li>async/await 구문을 처리하기 위해 <code class=\"language-text\">useEffect</code>를 사용하지 않아도 됩니다. 응답 데이터를 상태에 저장하고 요청하는 도중에 컴포넌트의 마운트가 해제되는 경우를 처리할 필요가 없습니다. 이런 것들을 통해 <code class=\"language-text\">React Query</code>는 우리의 코드를 단순화할 수 있게 해줍니다.</li>\n<li><code class=\"language-text\">React Query</code>는 다시 포커스가 활성화 되었을 때 자동으로 데이터를 다시 가져옵니다. (필요에 따라 비활성화도 가능합니다.)</li>\n<li>요청 시 오류가 발생하면 최대 3번까지 자동으로 재요청합니다.</li>\n</ul>\n<h2 id=\"refer\" style=\"position:relative;\"><a href=\"#refer\" aria-label=\"refer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refer</h2>\n<blockquote>\n<p><a href=\"https://www.carlrippon.com/getting-started-with-react-query-and-typescript/\">https://www.carlrippon.com/getting-started-with-react-query-and-typescript/</a></p>\n</blockquote>","frontmatter":{"date":"November 16, 2021","title":"React Query","categories":"TIL","author":"지걸","emoji":"📚"},"fields":{"slug":"/react-query/"}},"site":{"siteMetadata":{"siteUrl":"https://jiyaaany.netlify.app","comments":{"utterances":{"repo":"jiyaaany/jiyaaany.github.io"}}}}},"pageContext":{"slug":"/react-router-tips/","nextSlug":"/recoil/","prevSlug":"/react-query/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}