{"componentChunkName":"component---src-templates-blog-template-js","path":"/browser-rendering/","result":{"data":{"cur":{"id":"04e59556-8d59-509a-99b5-631ffaaf537e","html":"<h1 id=\"시작하며\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\" aria-label=\"시작하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작하며</h1>\n<p>기존에 알고 있던 브라우저 렌더링 과정과 추가적으로 알게 된 개념인 Reflow, Repaint를 정리하는 글입니다.</p>\n<h1 id=\"브라우저-렌더링\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"브라우저 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링</h1>\n<ol>\n<li>브라우저가 URI를 통해 서버로 요청한다.</li>\n<li>서버는 요청한 데이터를 HTML로 파싱할 수 있는 형태로 응답한다.</li>\n<li>응답 받은 데이터를 파싱하여 DOM, CSSOM을 생성한다.</li>\n<li>DOM 트리와 CSSOM 트리를 매핑하여 Render 트리를 생성한다.</li>\n<li>Render 트리를 바탕으로 Layout을 그리고 화면에 보여준다.</li>\n</ol>\n<h2 id=\"reflow--repaint\" style=\"position:relative;\"><a href=\"#reflow--repaint\" aria-label=\"reflow  repaint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reflow &#x26; Repaint</h2>\n<p>Reflow는 요소의 추가, 변경, 삭제로 인해 Layout 단계를 다시 수행하는 것을 말합니다. 이때 Render 트리 요소를 바탕으로 크기와 위치를 다시 계산하게 됩니다.</p>\n<blockquote>\n<p><strong>Reflow가 발생할 수 있는 상황</strong></p>\n<ul>\n<li>페이지 초기 렌더링 시 Layout 단계</li>\n<li>윈도우 사이즈가 변경될 때</li>\n<li>노드가 추가되거나 제거될 때</li>\n<li>요소의 위치, 크기가 변경되었을 때 (margin, padding, border, width, height 등)</li>\n<li>폰트가 변경되거나 텍스트, 이미지가 변경될 때</li>\n</ul>\n</blockquote>\n<p>Repaint는 Render 트리에 다시 그리는 과정을 말합니다. Reflow 후에 발생되거나 스타일 속성이 변경되었을 때 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Reflow와 Repaint 과정이 많이 발생될 경우 다시 계산하고 그리는 작업이 수행되기 때문에 성능 저하 문제가 생길 수 있습니다. \n그래서 우리는 Repaint, Reflow 가 발생하는 횟수를 최소화하는 것이 좋습니다.</code></pre></div>\n<h1 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h1>\n<h2 id=\"refer\" style=\"position:relative;\"><a href=\"#refer\" aria-label=\"refer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refer</h2>\n<p><a href=\"https://velog.io/@shyunju7/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0-%EB%A9%B4%EC%A0%91-%ED%9B%84%EA%B8%B0\">https://velog.io/@shyunju7/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0-%EB%A9%B4%EC%A0%91-%ED%9B%84%EA%B8%B0</a></p>","excerpt":"시작하며 기존에 알고 있던 브라우저 렌더링 과정과 추가적으로 알게 된 개념인 Reflow, Repaint를 정리하는 글입니다. 브라우저 렌더링 브라우저가 URI를 통해 서버로 요청한다. 서버는 요청한 데이터를 HTML로 파싱할 수 있는 형태로 응답한다. 응답 받은 데이터를 파싱하여 DOM, CSSOM을 생성한다. DOM 트리와 CSSOM 트리를 매핑하여 Render 트리를 생성한다. Render 트리를 바탕으로 Layout을 그리고 화면에 보여준다. Reflow & Repaint Reflow는 요소의 추가, 변경, 삭제로 인해 Layout 단계를 다시 수행하는 것을 말합니다. 이때 Render 트리 요소를 바탕으로 크기와 위치를 다시 계산하게 됩니다. Reflow가 발생할 수 있는 상황 페이지 초기 렌더링 시 Layout 단계 윈도우 사이즈가 변경될 때 노드가 추가되거나 제거될 때 요소의 위치, 크기가 변경되었을 때 (margin, padding, border, width, hei…","frontmatter":{"date":"December 31, 2021","title":"브라우저는 어떤 과정을 통해 렌더링 될까?","categories":"TIL","author":"지걸","emoji":"🌎"},"fields":{"slug":"/browser-rendering/"}},"next":{"id":"e7354b8b-ec67-5dfb-8c99-dc87c49c2d43","html":"<h1 id=\"시작하며\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\" aria-label=\"시작하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작하며</h1>\n<p>React를 주언어로 사용하고자 하는데 이야기를 나누다보니 Memoization의 개념에 대해 잘 모르고 있는 것 같아 정리해봅니다.</p>\n<h1 id=\"memoization\" style=\"position:relative;\"><a href=\"#memoization\" aria-label=\"memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memoization</h1>\n<ul>\n<li>이전 연산의 결과값을 <strong>저장</strong>해두고 동일한 입력이 들어오면 재활용하는 방법</li>\n<li>Memoized 된 내용을 재사용할 시, 가상 DOM에서 바뀐 부분을 확인하지 않아 성능이 향상됨.</li>\n</ul>\n<h2 id=\"1-redux\" style=\"position:relative;\"><a href=\"#1-redux\" aria-label=\"1 redux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Redux</h2>\n<p>Recoil이 아무리 편하긴 해도 .. Redux 공부도 꾸준히 해야겠다 ^^.</p>\n<h2 id=\"2-reactmemo\" style=\"position:relative;\"><a href=\"#2-reactmemo\" aria-label=\"2 reactmemo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. React.memo</h2>\n<p>컴포넌트를 <code class=\"language-text\">React.memo()</code>로 래핑 시, 렌더링 결과를 Memoizing하고 다음 렌더링에서 Props가 일치한다면 Memoizing된 내용을 재사용합니다.</p>\n<h2 id=\"3-usememo\" style=\"position:relative;\"><a href=\"#3-usememo\" aria-label=\"3 usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. useMemo</h2>\n<p><code class=\"language-text\">React.memo</code>와 흡사한데 <code class=\"language-text\">useMemo</code>는 함수의 결과 값을 Memoizing하여 불필요한 연산을 줄입니다.<br>\n(함수를 <code class=\"language-text\">useMemo</code>로 래핑)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function\">computeExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> 비싼 값 계산<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> memoizedValue <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">computedExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">useMemo</code>의 [dependency]가 변경되었을 때만 다시 계산함.</p>\n<h2 id=\"4-usecallback\" style=\"position:relative;\"><a href=\"#4-usecallback\" aria-label=\"4 usecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. useCallback</h2>\n<p><code class=\"language-text\">useMemo</code>는 특정 결과 값을 재사용하는 반면, <code class=\"language-text\">useCallback</code>은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> onToggle <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">id</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setUsers</span><span class=\"token punctuation\">(</span>\n      users<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span> <span class=\"token operator\">=></span>\n        user<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span> id <span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>user<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">active</span><span class=\"token operator\">:</span> <span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>active <span class=\"token punctuation\">}</span> <span class=\"token operator\">:</span> user\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>users<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>CreateUser onToggle<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onToggle<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>메모제이션용 메모리가 추가로 필요하므로, 불필요한 Props 비교를 줄이기 위해서 <code class=\"language-text\">useCallback</code>, <code class=\"language-text\">useMemo</code>, <code class=\"language-text\">React.memo</code>는 컴포넌트의 성능을 실제로 개선할 수 있는 상황에서만 사용</p>\n</blockquote>","frontmatter":{"date":"December 29, 2021","title":"Memoization","categories":"TIL","author":"지걸","emoji":"📚"},"fields":{"slug":"/memoization/"}},"prev":{"id":"a0c99115-2408-55f4-8d8b-2a4d8c379491","html":"<h1 id=\"시작하며\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\" aria-label=\"시작하며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작하며</h1>\n<p>Nuxt 공식 문서에 있는 <a href=\"https://nuxtjs.org/docs/features/data-fetching\">Data Fetching</a> w에 관련된 내용을 번역한 글입니다.</p>\n<h1 id=\"data-fetching\" style=\"position:relative;\"><a href=\"#data-fetching\" aria-label=\"data fetching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data Fetching</h1>\n<blockquote>\n<p>Nuxt에서는 API로부터 데이터를 가져오는 2가지 방법이 있습니다. <code class=\"language-text\">fetch</code> 메서드와 <code class=\"language-text\">asyncData</code> 메서드를 사용해 데이터를 가져올 수 있습니다.</p>\n</blockquote>\n<p>Nuxt는 client-side 어플리케이션에서 데이터를 로딩하기 위한 전통적인 Vue의 패턴을 제공합니다. (컴포넌트의 <code class=\"language-text\">mounted()</code> 훅에서데이터를 가져오는 것)\n그러나 범용적으로는 server-side 렌더링 때에 데이터를 가져올 수 있도록 Nuxt의 특수 훅들을 사용해야 합니다.\n이렇게 하면 페이지에 필요한 모든 데이터와 함께 페이지를 렌더링 할 수 있습니다.</p>\n<p>Nuxt의 비동기 데이터를 로딩하는 두가지 hooks:</p>\n<ul>\n<li><code class=\"language-text\">asyncData</code>: 이 훅은 page 컴포넌트에서만 사용 가능합니다. 이 훅은 client-side 렌더링 동안 로딩되는 공간을 표시하지 않습니다.</li>\n</ul>\n<p>대신에, 이 훅은 해결될 때까지 페이지 이동을 막고 실패할 경우 에러 페이지를 보여줍니다.</p>\n<ul>\n<li><code class=\"language-text\">fetch</code> (Nuxt 2.12+): 이 훅은 모든 컴포넌트에서 사용 가능합니다. 그리고 로딩 상태(client-side 렌더링 중)와 에러를 렌더링 하기 위한 shortcuts를 제공합니다.</li>\n</ul>\n<p>위 훅들은 데이터를 가져오는 라이브러리에서 사용할 수 있습니다. HTTP API 요청을 위한 <a href=\"https://axios.nuxtjs.org/\">@nuxt/axios</a> 나 <a href=\"https://http.nuxtjs.org/\">@nuxt/http</a> 를 사용하는 것을 권장합니다.\n인증 header 설정을 위한 가이드와 같은 이 라이브러리들에 대한 더 많은 정보는 documentation를 찾아보시기 바랍니다.</p>\n<blockquote>\n<p>만약 <code class=\"language-text\">fetch</code>나 <code class=\"language-text\">asyncData</code>를 mixin 내에 정의하고 page 컴포넌트에서도 정의하는 경우, mixin 함수는 덮여씌어집니다.</p>\n</blockquote>\n<h2 id=\"the-fetch-hook\" style=\"position:relative;\"><a href=\"#the-fetch-hook\" aria-label=\"the fetch hook permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The fetch hook</h2>\n<blockquote>\n<p>Nuxt 2.12 이전의 page 컴포넌트에서만 동작되고 컴포넌트에서 접근할 수 없는 <code class=\"language-text\">fetch</code> 훅과는 다릅니다. 만약 <code class=\"language-text\">fetch()</code>가 <code class=\"language-text\">context</code> argument를 사용할 수 있다면,\n그것은 레거시 fetch 으로 취급됩니다. 이것은 deprecated 되었으며 <code class=\"language-text\">asyncData</code> 또는 anonymouse middleware로 교체하여야 합니다.</p>\n</blockquote>\n<p><code class=\"language-text\">fetch</code>는 컴포넌트가 생성된 후 server-side 렌더링 동안 client에서 불려집니다. fetch 훅은 promise(명시적, 또는 <code class=\"language-text\">async/await</code>를 사용한 암시적)를 반환합니다.</p>\n<ul>\n<li>서버에서는 초기 페이지 렌더 전</li>\n<li>클라이언트에서는 컴포넌트가 mounted 되고 일정 시간 경과</li>\n</ul>\n<blockquote>\n<p>static hosting에서, fetch 훅은 page 생성 중에만 불립니다. 그리고 결과는 클라이언트에서 사용할 수 있도록 캐싱됩니다.\n캐시 충돌을 방지하려면 컴포넌트의 이름을 지정하거나 고유한 fetchKey를 제공해야 합니다.</p>\n</blockquote>\n<h3 id=\"usage\" style=\"position:relative;\"><a href=\"#usage\" aria-label=\"usage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Usage</h3>\n<h4 id=\"fetching-data\" style=\"position:relative;\"><a href=\"#fetching-data\" aria-label=\"fetching data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fetching data</h4>\n<p>fetch 훅 내에서는 컴포넌트의 <code class=\"language-text\">this</code> 객체에 접근할 수 있습니다.</p>\n<blockquote>\n<p>다른 속성을 수정하려면 <code class=\"language-text\">data()</code> 안에 미리 선언해야 합니다. 그리고 fetch에서 가져온 데이터는 data에서 선언한 속성에 할당할 수 있습니다.</p>\n</blockquote>\n<h4 id=\"changing-fetch-behavior\" style=\"position:relative;\"><a href=\"#changing-fetch-behavior\" aria-label=\"changing fetch behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Changing fetch behavior</h4>\n<p><code class=\"language-text\">fetchOnServer</code>: <code class=\"language-text\">Boolean</code> 또는 <code class=\"language-text\">Function</code> (default: <code class=\"language-text\">true</code>) 페이지가 server-rendering 때 <code class=\"language-text\">fetch</code>가 호출됩니다.</p>\n<p><code class=\"language-text\">fetchKey</code>: <code class=\"language-text\">String</code> 또는 <code class=\"language-text\">Function</code> (컴포넌트 scope ID 또는 컴포넌트명이 기본) 컴포넌트의 fetch 결과를 식별할 수 있는 key (또는 고유 키를 생성하는 함수) (Nuxt 2.15+ 사용 가능).\n페이지가 server-rendered 될 때 이 키는 서버 측 결과를 <code class=\"language-text\">fetch()</code> 클라이언트 측 구성 요소 데이터 에 매핑하는 데 사용됩니다. <a href=\"https://github.com/nuxt/nuxt.js/pull/8466\">원본 PR</a> 에서 더 많은 정보를 얻을 수 있습니다.</p>\n<p><code class=\"language-text\">fetchDelay</code>: <code class=\"language-text\">Integer</code> (default: <code class=\"language-text\">200</code>), 최소 실행 시간을 초단위로 설정한다. (빠른 깜빡임을 피하기 위해)</p>\n<p><code class=\"language-text\">fetchOnServer</code>는 참/거짓, <code class=\"language-text\">fetch</code>는 clinet-side에서만 호출할 수 있고, server-side 컴포넌트에서는 <code class=\"language-text\">$fetchState.pending</code>는 <code class=\"language-text\">true</code>를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">data</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">posts</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">async</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>posts <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$http<span class=\"token punctuation\">.</span><span class=\"token function\">$get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.nuxtjs.dev/posts'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">fetchOnServer</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// multiple components can return the same `fetchKey` and Nuxt will track them both separately</span>\n  <span class=\"token literal-property property\">fetchKey</span><span class=\"token operator\">:</span> <span class=\"token string\">'site-sidebar'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// alternatively, for more control, a function can be passed with access to the component instance</span>\n  <span class=\"token comment\">// It will be called in `created` and must not depend on fetched data</span>\n  <span class=\"token function\">fetchKey</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">getCounter</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// getCounter is a method that can be called to get the next number in a sequence</span>\n    <span class=\"token comment\">// as part of generating a unique fetchKey.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>someOtherData <span class=\"token operator\">+</span> <span class=\"token function\">getCounter</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sidebar'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"accessing-the-fetch-state\" style=\"position:relative;\"><a href=\"#accessing-the-fetch-state\" aria-label=\"accessing the fetch state permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Accessing the fetch state</h4>\n<p><code class=\"language-text\">fetch</code> 훅은 다음과 같은 특성을 가진 컴포넌트의 레벨에서 <code class=\"language-text\">this.$fetchState</code>을 나타냅니다.</p>\n<ul>\n<li><code class=\"language-text\">pending</code>은 clinet-side 에서 <code class=\"language-text\">fetch</code>가 호출되었을 때 <code class=\"language-text\">Boolean</code> 값을 나타냅니다.</li>\n<li><code class=\"language-text\">error</code>는 <code class=\"language-text\">fetch</code> 훅으로부터 <code class=\"language-text\">null</code>이거나 <code class=\"language-text\">Error</code>를 반환한 경우입니다.</li>\n<li><code class=\"language-text\">timestamp</code>는 마지막 fetch를 나타내는 시간입니다. <code class=\"language-text\">keep-alive</code>를 사용해 캐싱하는데 유용합니다.</li>\n</ul>\n<p>추가로 Nuxt에서 불려지는 fetch 외에도, 컴포넌트 내에서 <code class=\"language-text\">this.$fetch()</code>를 통해 fetch를 호출할 수 있다. (e.g. 비동기 데이터를 리로드)</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p v-if=&quot;$fetchState.pending&quot;&gt;Fetching mountains...&lt;/p&gt;\n    &lt;p v-else-if=&quot;$fetchState.error&quot;&gt;An error occurred :(&lt;/p&gt;\n    &lt;div v-else&gt;\n      &lt;h1&gt;Nuxt Mountains&lt;/h1&gt;\n      &lt;ul&gt;\n        &lt;li v-for=&quot;mountain of mountains&quot;&gt;{{ mountain.title }}&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;button @click=&quot;$fetch&quot;&gt;Refresh&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        mountains: []\n      }\n    },\n    async fetch() {\n      this.mountains = await fetch(\n        &#39;https://api.nuxtjs.dev/mountains&#39;\n      ).then(res =&gt; res.json())\n    }\n  }\n&lt;/script&gt;</code></pre></div>\n<blockquote>\n<p>fetch 훅 말고도 <code class=\"language-text\">this.$nuxt.context</code>를 사용해 Nuxt <strong>context</strong> 에 접근할 수 있다.</p>\n</blockquote>\n<h3 id=\"listening-to-query-string-changes\" style=\"position:relative;\"><a href=\"#listening-to-query-string-changes\" aria-label=\"listening to query string changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Listening to query string changes</h3>\n<p><code class=\"language-text\">fetch</code> 훅은 기본적으로 쿼리 스트링이 변경되었을 때 호출되지 않는다. 쿼리 변경을 감시하려면 <code class=\"language-text\">$route.query</code>를 추가해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">watch</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string-property property\">'$route.query'</span><span class=\"token operator\">:</span> <span class=\"token string\">'$fetch'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">async</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Called also on query changes</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"caching\" style=\"position:relative;\"><a href=\"#caching\" aria-label=\"caching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caching</h3>\n<p><code class=\"language-text\">&lt;nuxt /></code>와 <code class=\"language-text\">&lt;nuxt-child /></code>컴포넌트에 <code class=\"language-text\">keep-alive</code> 디렉티브를 사용해 이미 방문한 페이지에서 호출한 <code class=\"language-text\">fetch</code>를 저장할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>template<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>nuxt keep<span class=\"token operator\">-</span>alive <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>template<span class=\"token operator\">></span></code></pre></div>\n<p>또한 <code class=\"language-text\">&lt;nuxt></code> 컴포넌트에 <code class=\"language-text\">keep-alive-props</code> 등의 <a href=\"https://vuejs.org/v2/api/#keep-alive\">props</a> 를 구성할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>nuxt keep<span class=\"token operator\">-</span>alive <span class=\"token operator\">:</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">-</span>props<span class=\"token operator\">=</span><span class=\"token string\">\"{ max: 10 }\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>10개의 페이지 컴포넌트만 저장됩니다.</p>\n<h3 id=\"error-handling\" style=\"position:relative;\"><a href=\"#error-handling\" aria-label=\"error handling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Error handling</h3>\n<blockquote>\n<p>데이터를 가져오는 중 에러가 발생한다면 정상적인 Nuxt 오류 페이지가 로드되지 않습니다. <code class=\"language-text\">fetch()</code> 내의 Nuxt <code class=\"language-text\">redirect</code>나 <code class=\"language-text\">error</code> 메서드를 사용하지 않는 대신에\n컴포넌트 내에서 <code class=\"language-text\">$fetchState.error</code>를 사용해 처리해야 합니다.</p>\n</blockquote>\n<p>데이터를 가져오는 중 error가 있다면 <code class=\"language-text\">$fetchState.error</code>를 확인해 에러 메시지를 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p v-if=&quot;$fetchState.pending&quot;&gt;Loading....&lt;/p&gt;\n    &lt;p v-else-if=&quot;$fetchState.error&quot;&gt;Error while fetching mountains&lt;/p&gt;\n    &lt;ul v-else&gt;\n      &lt;li v-for=&quot;(mountain, index) in mountains&quot; :key=&quot;index&quot;&gt;\n        {{ mountain.title }}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        mountains: []\n      }\n    },\n    async fetch() {\n      this.mountains = await fetch(\n        &#39;https://api.nuxtjs.dev/mountains&#39;\n      ).then(res =&gt; res.json())\n    }\n  }\n&lt;/script&gt;</code></pre></div>\n<h3 id=\"using-code-classlanguage-textactivatedcode-hook\" style=\"position:relative;\"><a href=\"#using-code-classlanguage-textactivatedcode-hook\" aria-label=\"using code classlanguage textactivatedcode hook permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using <code class=\"language-text\">activated</code> hook</h3>\n<p>Nuxt는 마지막 <code class=\"language-text\">fetch</code> 호출(ssr 포함)을 <code class=\"language-text\">this.$fetchState.timestamp</code>에 담아두고 있습니다.\n<code class=\"language-text\">activated</code>훅이 포함된 속성을 사용하여 <code class=\"language-text\">fetch</code>의 30초 캐시를 추가할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt; ... &lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        posts: []\n      }\n    },\n    activated() {\n      // Call fetch again if last fetch more than 30 sec ago\n      if (this.$fetchState.timestamp &lt;= Date.now() - 30000) {\n        this.$fetch()\n      }\n    },\n    async fetch() {\n      this.posts = await fetch(&#39;https://api.nuxtjs.dev/posts&#39;).then(res =&gt;\n        res.json()\n      )\n    }\n  }\n&lt;/script&gt;</code></pre></div>\n<p>마지막 <code class=\"language-text\">fetch</code> 호출이 30초 전인 경우 동일 페이지로의 탐색이 호출되지 않습니다.</p>\n<h2 id=\"async-data\" style=\"position:relative;\"><a href=\"#async-data\" aria-label=\"async data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async Data</h2>\n<blockquote>\n<p><code class=\"language-text\">asyncData</code>는 <strong>pages</strong>에서만 사용할 수 있고 훅 내에서 <code class=\"language-text\">this</code>에 접근할 수 없습니다.</p>\n</blockquote>\n<p><code class=\"language-text\">asyncData</code>는 범용 데이터를 가져오기 위한 다른 훅입니다. 비동기 상태를 저장하기 위한 속성 정의가 필요한 <code class=\"language-text\">fetch</code>와 달리 <code class=\"language-text\">asyncData</code>는\n컴포넌트의 로컬 state와 반환 값을 병합하기만 하면 됩니다. 여기 @nuxt/http 라이브러리를 사용한 예제가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;{{ post.title }}&lt;/h1&gt;\n    &lt;p&gt;{{ post.description }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    async asyncData({ params, $http }) {\n      const post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)\n      return { post }\n    }\n  }\n&lt;/script&gt;</code></pre></div>\n<p><code class=\"language-text\">fetch</code>와 달리 <code class=\"language-text\">asyncData</code> 훅으로 리턴된 promise는 route 전환 중에 해결됩니다. 이것은 client-side 전환 중에는 “loading placeholder”가 표시되지 않는다는걸 의미합니다.\n(loading bar를 사용하여 사용자에게 로드 상태를 나타낼 수 있음).\n대신 Nuxt는 다음 페이지나 에러 페이지를 보여주기 전에 <code class=\"language-text\">asyncData</code> 훅이 완료될 때까지 기다립니다.</p>\n<p>이 훅은 page-level 컴포넌트에서만 사용 가능합니다. <code class=\"language-text\">fetch</code>와는 다르게 <code class=\"language-text\">asyncData</code>는 컴포넌트의 <code class=\"language-text\">this</code>에 접근할 수 없습니다.\n대신, argument로 <a href=\"https://nuxtjs.org/docs/concepts/context-helpers/\">the context</a> 를 받습니다. 이것을 사용해 몇몇의 데이터를 가져올 수 있고 Nuxt는 자동으로\n컴포넌트의 데이터와 리턴 객체를 병합할 수 있습니다.</p>\n<p>다음 예시는, API로부터 데이터를 가져올 때 권장하는 @nuxt/http 라이브러리를 사용했습니다.</p>\n<h3 id=\"async-data-in-components\" style=\"position:relative;\"><a href=\"#async-data-in-components\" aria-label=\"async data in components permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async data in components?</h3>\n<p>컴포넌트는 <code class=\"language-text\">asyncData</code>를 갖고 있지 않기 때문에 컴포넌트 내에서 직접 server-side 비동기 데이터를 가져올 수 없습니다.\n제한을 극복하기 위해 3가지 옵션을 사용할 수 있습니다.</p>\n<ol>\n<li>Nuxt 2.12 이후 버전에서부터 사용 가능한 <a href=\"https://nuxtjs.org/docs/features/data-fetching/#the-fetch-hook\">새로운 <code class=\"language-text\">fetch</code> hook</a> 을 사용합니다.</li>\n<li><code class=\"language-text\">mounted</code> 훅 안에서 API 호출을 합니다. 그리고 loaded 시점에 data 속성을 지정합니다. 단점: server side rendering 에서는 작동하지 않습니다.</li>\n<li>page 컴포넌트의 <code class=\"language-text\">asyncData</code> 안에서 API를 호출합니다. 그리고 하위 컴포넌트로 data를 props로 전달합니다. Server rendering은 잘 동작합니다.</li>\n</ol>\n<p>단점: 다른 컴포넌트에서 데이터를 로딩하기 위해 page의 <code class=\"language-text\">asyncData</code>는 가독성이 떨어질 수 있습니다.</p>\n<h3 id=\"listening-to-query-changes\" style=\"position:relative;\"><a href=\"#listening-to-query-changes\" aria-label=\"listening to query changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Listening to query changes</h3>\n<p>기본적으로 <code class=\"language-text\">asyncData</code>는 query string 변경에 의해 호출되지 않습니다. page 컴포넌트를 작성할 때처럼 동작을 변경하려면 page 컴포넌트의\n<code class=\"language-text\">watchQuery</code> 속성으로 받는 파라미터를 설정할 수 있습니다.</p>","frontmatter":{"date":"January 07, 2022","title":"Nuxt - Data Fetching","categories":"TIL","author":"지걸","emoji":"👀"},"fields":{"slug":"/nuxt-data-fetching/"}},"site":{"siteMetadata":{"siteUrl":"https://jiyaaany.netlify.app","comments":{"utterances":{"repo":"jiyaaany/jiyaaany.github.io"}}}}},"pageContext":{"slug":"/browser-rendering/","nextSlug":"/memoization/","prevSlug":"/nuxt-data-fetching/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}