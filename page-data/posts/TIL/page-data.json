{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/TIL","result":{"pageContext":{"currentCategory":"TIL","categories":["All","TIL","CSS","Javascript","CS","react","algorithm","javascript","ToDo","idea","experience"],"edges":[{"node":{"id":"6587623d-35a0-5861-a8b4-95fe458a64e3","excerpt":"Next.js 프레임워크 구조 : url과 매칭되는 것들 Date Fetching SSR: 서버 사이드 렌더링으로,  함수를 활용해 만들 수 있다. 서버에 요청이 생길 때마다 외부 데이터를 조회해서 보여줄 수 있다. CSR: 클라이언트 사이드 렌더링으로, 일반 React를 사용하는 것과 같다. SSG: 정적 사이트 제너레이션, 빌드 타임 때 미리 필요한 데이터를 가져와 화면을 그려놓는다. 로 실행한 환경에서는 SSR과 동일하게 동작하고 빌드 후 실행했을 때 순기능을 확인할 수 있다. 빌드 시 가져온 데이터로 그려주기 때문에 아무리 새로고침을 해도 데이터가 변경되거나 리패치 되지 않는다. ISR:  안에서 동작하는거지만 특정 주기를 지정해주면 그 주기마다 리제너레이션하여 데이터를 업데이트할 수 있다. SSR은 매번 서버로 호출하기 때문에 서버 부하를 가져올 수 있어 SSG + ISR을 동시에 사용하는 것을 권장한다. Layout 를 활용해서 페이지에 공통적으로 보여지는 레이아웃들을 …","fields":{"slug":"/fastcampus-nextjs/"},"frontmatter":{"categories":"TIL","title":"Next.js 완전정복","date":"March 14, 2023"}},"next":{"fields":{"slug":"/next-js/"}},"previous":null},{"node":{"id":"13699728-3d43-506a-94a0-64875ca0d7ae","excerpt":"Getting Started (시작하기) 애플리케이션 루트 경로에 와  디렉토리가 생성된다. : 디렉토리 내부의 파일 명은 라우터와 연결된다. 예를 들어, 는  과 매핑된다. : 이미지, 폰트 등 정적 리소스를 저장한다.  폴더 안 파일들은 base URL()으로 코드가 실행되기 전에 참조할 수 있다. Next.js는 페이지 개념을 중심으로 만들어졌다. 페이지란  디렉토리 내부의 , , , or  타입의 리액트 컴포넌트를 말한다.\n뿐만 아니라 파일 이름을 통해 dynamic route 파라미터를 설정할 수 있다.  디렉토리 안의  파일은 시작을 위한 파일이다. 사용자가 애플리케이션을 방문했을 때 렌더링 되는 페이지이다. 지금까지 우리는: 자동 컴파일과 번들링 React Fast Refresh 의 정적 generation 및 서버 사이드 렌더링 base URL과 매핑되는  디렉토리를 통한 정적 파일 제공 Basic Features (기본적인 기능) Pages  디렉토리의 각 페이지는…","fields":{"slug":"/next-js/"},"frontmatter":{"categories":"TIL","title":"Next.js 공식문서 번역","date":"February 15, 2023"}},"next":{"fields":{"slug":"/css-wiki/"}},"previous":{"fields":{"slug":"/fastcampus-nextjs/"}}},{"node":{"id":"0bf87de4-4026-5349-bf2e-67bfb2a34ba1","excerpt":"Grid : 요소를 격자 형태로 배치 : 요소를 격자 형태로 배치하는 것은 동일하지만  속성과 동일하게 내용 크기 만큼만 자리를 차지한다. : grid 요소의 한 컬럼에 배치할 하위 요소들의 사이즈를 정하는 속성 Event  VS : currentTarget 은 실제 이벤트가 발생한 요소를 가져오고 target 은 이벤트가 등록된 요소를 반환한다. Button  일 경우\nbuttonElement 에서 value 속성을 주면 버튼의 텍스트를 설정할 수 있다.  태그 일 경우\nbutton 태그일 경우 buttonElement 에서 innerText를 주어 버튼 내의 텍스트를 변경할 수 있다.","fields":{"slug":"/cats-directory/"},"frontmatter":{"categories":"react TIL","title":"고양이 검색 과제","date":"September 07, 2022"}},"next":{"fields":{"slug":"/big-number/"}},"previous":{"fields":{"slug":"/react-wiki/"}}},{"node":{"id":"c2bff4e9-1e69-5f70-94af-5214e90034fd","excerpt":"링크 모음집 URL, URI, URN의 차이","fields":{"slug":"/link/"},"frontmatter":{"categories":"TIL","title":"link 모음집","date":"May 24, 2022"}},"next":{"fields":{"slug":"/animation/"}},"previous":{"fields":{"slug":"/how-to-use-async-in-use-effect/"}}},{"node":{"id":"945b5477-4a7a-57a6-9a2f-3a1cb0b80af6","excerpt":"VS  은 요소의 상태가 변할 때 애니메이션을 실행한다.  속성은 요소의 모양과 동작을 키프레임 단위로 변경할 수 있다.\n키프레임 동작은 재생 횟수, 방향 등 여러 속성으로 제어할 수 있다. 가장 큰 차이는  은 요소의 상태가 바뀔 때의 상태를 애니메이션으로 표현하지만,  속성은 요소의 상태 변화와 상관없이\n애니메이션을 실행한다. 또한  속성으로 프레임을 추가할 수 있다. transition의 예)  :  규칙을 준수 해 정의한 애니메이션 이름 : 애니메이션이 얼마에 걸쳐 일어날지 결정 : 로드 이후 어느 정도 텀을 두어 애니메이션이 시작될지 지정 : 애니메이션의 방향 지정 : 애니메이션이 몇 번 반복될지 지정 로 지정하면 무한반복 : 애니메이션을 멈추거나 다시 시작 : 중간 상태들의 전환 간격을 지정 : 시작되기 전이나 끝나고 난 후 어떤 값이 적용될지 지정 animation의 성능 문제 ,  속성은 애니메이션에 사용했을 때 성능 저하를 유발한다. 윌보이드 - 부드러운 애니메이션…","fields":{"slug":"/animation/"},"frontmatter":{"categories":"TIL","title":"CSS 애니메이션","date":"May 04, 2022"}},"next":{"fields":{"slug":"/algorithm/"}},"previous":{"fields":{"slug":"/link/"}}},{"node":{"id":"7c4c3ad9-b22e-572a-bab5-3316945d97a4","excerpt":"시작하며 Vue의 반응형 시스템의 세부사항을 다뤄봅니다. 반응형에 대해 깊이 알아보기 변경 내용을 추적하는 방법 Vue 인스턴스에  옵션으로 전달하면 모든 속성에 Object.defineProperty 를 사용하여 getter/setters 로 변환합니다.\n모든 컴포넌트 인스턴스는 해당 watcher 인스턴스가 있으며, 이 인스턴스는 “수정”된 모든 속성을 기록합니다. 나중에 종속적인 setter가 트리거 되면 watcher에 알리고 다시 렌더링 됩니다.\n 변경 감지 경고 Vue는 속성의 추가 제거를 감지할 수 없습니다.","fields":{"slug":"/vue-reactivity/"},"frontmatter":{"categories":"TIL","title":"반응형에 대해 깊이 알아보기","date":"January 24, 2022"}},"next":{"fields":{"slug":"/vue-conditional-rendering/"}},"previous":{"fields":{"slug":"/algorithm/"}}},{"node":{"id":"c34407b6-4fcc-5c9c-acec-d50f9a4c5761","excerpt":"시작하며 Vue 프레임워크에서 조건부 렌더링을 위한 디렉티브는 와 가 있습니다. 이번에는 두 가지 디렉티브의 차이점에 대해 알아봅시다. v-if VS v-show  디렉티브의 값이 이면 렌더링 되고 이면 렌더링 되지 않습니다. 2.1.0 버전부터  디렉티브도 추가되어 기존에 if문을 사용하던대로 디렉티브를 사용할 수 있습니다.  와 마찬가지로 디렉티브 값이 일 때 렌더링 됩니다.  Vue에서 으로 감싼 뒤 callback을 통해 DOM을 조작할 수 있다. 이렇게 되면 데이터 갱신 후 UI까지 렌더링한 후에  함수를 최종적으로 수행한다. 데이터가 업데이트되고 난 직후,\nUI가 갱신될 때 DOM을 찾지 못하는 현상을 개선하고자 사용한다. ex. 차이점 가장 큰 차이점은 는 실제 컴포넌트가 제거되고 생성되는 반면 는 css의  속성만 변경된다는 점입니다. 마치며 Refer https://kr.vuejs.org/v2/guide/conditional.html https://vuejs-kr.…","fields":{"slug":"/vue-conditional-rendering/"},"frontmatter":{"categories":"TIL","title":"Vue 꿀팁 🍯","date":"January 21, 2022"}},"next":{"fields":{"slug":"/api-library-framework/"}},"previous":{"fields":{"slug":"/vue-reactivity/"}}},{"node":{"id":"87ec4692-0f68-592f-a474-97942cda0970","excerpt":"API (Application Programming Interface) ? 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스 특징 구현과 독립적으로 사양만 정의되어 있다. API에 따라 접근 권한이 필요할 수 있다. Library ? 응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어 특징 독립성을 가진다. 응용 프로그램이 능동적으로 라이브러리를 사용한다. Framework ? 응용 프로그램이나 소프트웨어의 솔루션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경 특징 상호협력하는 클래스와 인터페이스의 집합이다. 응용 프로그램이 수동적으로 프레임워크에 의해 사용된다. API VS Library VS Framework Library와 API의 차이점은 구현 로직의 유무이다. Library와 Framework의 차이점은 응용 프로그램의 흐름 주도권을 누가 가지고 있느냐 이다. Refer https://www.youtube…","fields":{"slug":"/api-library-framework/"},"frontmatter":{"categories":"TIL","title":"API VS Library VS Framework","date":"January 11, 2022"}},"next":{"fields":{"slug":"/learning-javascript/"}},"previous":{"fields":{"slug":"/vue-conditional-rendering/"}}},{"node":{"id":"d3634ae5-9245-5730-868e-cc504886919c","excerpt":"프로그래밍 프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. 문제를 명확히 이해하고 적절한 해결 방은을 찾아 기계가 실행할 수 있을 정도로 요구를 설명하는 작업이며, 이 결과물이 바로 코드이다. 컴파일러와 인터프리터 프로그래밍 언어를 사용해 프로그램을 작성 후 컴퓨터가 이해할 수 있는 기계어로 변환해주는 번역기를 컴파일러(Compiler) 혹은 인터프리터(Interpreter)라고 한다. 자바스크립트의 특징 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다.\n자바스크립트는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기 때문에 컴파일러 언어라고 할 수는 없다. 변수 변수는 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름을 말한다. 식별자 변수의 이름을 식별자(Identifier)라…","fields":{"slug":"/learning-javascript/"},"frontmatter":{"categories":"TIL","title":"Javascript를 알아봅시다 !","date":"January 09, 2022"}},"next":{"fields":{"slug":"/nuxt-data-fetching/"}},"previous":{"fields":{"slug":"/api-library-framework/"}}},{"node":{"id":"a0c99115-2408-55f4-8d8b-2a4d8c379491","excerpt":"시작하며 Nuxt 공식 문서에 있는 Data Fetching w에 관련된 내용을 번역한 글입니다. Data Fetching Nuxt에서는 API로부터 데이터를 가져오는 2가지 방법이 있습니다.  메서드와  메서드를 사용해 데이터를 가져올 수 있습니다. Nuxt는 client-side 어플리케이션에서 데이터를 로딩하기 위한 전통적인 Vue의 패턴을 제공합니다. (컴포넌트의  훅에서데이터를 가져오는 것)\n그러나 범용적으로는 server-side 렌더링 때에 데이터를 가져올 수 있도록 Nuxt의 특수 훅들을 사용해야 합니다.\n이렇게 하면 페이지에 필요한 모든 데이터와 함께 페이지를 렌더링 할 수 있습니다. Nuxt의 비동기 데이터를 로딩하는 두가지 hooks: : 이 훅은 page 컴포넌트에서만 사용 가능합니다. 이 훅은 client-side 렌더링 동안 로딩되는 공간을 표시하지 않습니다. 대신에, 이 훅은 해결될 때까지 페이지 이동을 막고 실패할 경우 에러 페이지를 보여줍니다.  (N…","fields":{"slug":"/nuxt-data-fetching/"},"frontmatter":{"categories":"TIL","title":"Nuxt - Data Fetching","date":"January 07, 2022"}},"next":{"fields":{"slug":"/browser-rendering/"}},"previous":{"fields":{"slug":"/learning-javascript/"}}},{"node":{"id":"04e59556-8d59-509a-99b5-631ffaaf537e","excerpt":"시작하며 기존에 알고 있던 브라우저 렌더링 과정과 추가적으로 알게 된 개념인 Reflow, Repaint를 정리하는 글입니다. 브라우저 렌더링 브라우저가 URI를 통해 서버로 요청한다. 서버는 요청한 데이터를 HTML로 파싱할 수 있는 형태로 응답한다. 응답 받은 데이터를 파싱하여 DOM, CSSOM을 생성한다. DOM 트리와 CSSOM 트리를 매핑하여 Render 트리를 생성한다. Render 트리를 바탕으로 Layout을 그리고 화면에 보여준다. Reflow & Repaint Reflow는 요소의 추가, 변경, 삭제로 인해 Layout 단계를 다시 수행하는 것을 말합니다. 이때 Render 트리 요소를 바탕으로 크기와 위치를 다시 계산하게 됩니다. Reflow가 발생할 수 있는 상황 페이지 초기 렌더링 시 Layout 단계 윈도우 사이즈가 변경될 때 노드가 추가되거나 제거될 때 요소의 위치, 크기가 변경되었을 때 (margin, padding, border, width, hei…","fields":{"slug":"/browser-rendering/"},"frontmatter":{"categories":"TIL","title":"브라우저는 어떤 과정을 통해 렌더링 될까?","date":"December 31, 2021"}},"next":{"fields":{"slug":"/memoization/"}},"previous":{"fields":{"slug":"/nuxt-data-fetching/"}}},{"node":{"id":"e7354b8b-ec67-5dfb-8c99-dc87c49c2d43","excerpt":"시작하며 React를 주언어로 사용하고자 하는데 이야기를 나누다보니 Memoization의 개념에 대해 잘 모르고 있는 것 같아 정리해봅니다. Memoization 이전 연산의 결과값을 저장해두고 동일한 입력이 들어오면 재활용하는 방법 Memoized 된 내용을 재사용할 시, 가상 DOM에서 바뀐 부분을 확인하지 않아 성능이 향상됨. 1. Redux Recoil이 아무리 편하긴 해도 .. Redux 공부도 꾸준히 해야겠다 ^^. 2. React.memo 컴포넌트를 로 래핑 시, 렌더링 결과를 Memoizing하고 다음 렌더링에서 Props가 일치한다면 Memoizing된 내용을 재사용합니다. 3. useMemo 와 흡사한데 는 함수의 결과 값을 Memoizing하여 불필요한 연산을 줄입니다. (함수를 로 래핑) 의 [dependency]가 변경되었을 때만 다시 계산함. 4. useCallback 는 특정 결과 값을 재사용하는 반면, 은 특정 함수를 새로 만들지 않고 재사용하고 싶을…","fields":{"slug":"/memoization/"},"frontmatter":{"categories":"TIL","title":"Memoization","date":"December 29, 2021"}},"next":{"fields":{"slug":"/open-source/"}},"previous":{"fields":{"slug":"/browser-rendering/"}}},{"node":{"id":"5da46d7d-b39f-5c71-ae46-8b45e321b7d6","excerpt":"컴포넌트, 다시 생각하기 기능적Type 분류: props, hooks 특징적Feature 분류: 스타일, 로직, 전역상태, 리모트 데이터 스키마 리모트 데이터 스키마 ? API 서버에서 내려주는 데이터의 모양 함께 두기 (Co-locate) 비슷한 관심사라면 가까운 곳 함께 두기  id 값만 Props로 전달받아 다른 컴포넌트 간의 의존성 줄이기 데이터를 ID 기반으로 정리하기 데이터 정규화(Nomalization) 데이터 정규화는 normalizr 패키지를 사용해 쉽게 할 수 있다. 왜 나는 React를 사랑하는가 발표자 안희종님 | 플렉스팀 왜 나는 널 사랑하는가 클리어한 멘탈 모델, 작고 단단한 코어 Learn Once, Write AnyWhere (한번 배우면 여러 환경에서 사용할 수 있다는 의미) 꾸준히 성장하는 거대한 커뮤니티 도전적인 과제, 우아한 해결책 Fiber, Hooks, Suspense, … React는 UI 프로그래밍 언어이다? 프로그래밍 언어 리액트 값 R…","fields":{"slug":"/feconf/"},"frontmatter":{"categories":"TIL","title":"FEConf 2021","date":"December 29, 2021"}},"next":{"fields":{"slug":"/javascript/"}},"previous":{"fields":{"slug":"/bucket-list/"}}},{"node":{"id":"4ed00cf2-7836-574d-ba53-a13fbdaa451a","excerpt":"시작하며 프로그래머스 과제관에 있는 고양이 사진 검색 사이트 과제를 진행하며 JavaScript 면접 질문으로 자주 만나는 개념에 대해 정리해보았습니다. JavaScript this 기본 바인딩 (전역객체) 일반적으로 는 자바스크립트 환경의 전역 객체입니다. (브라우저의 window 객체) 의 첫번째 동작 방식은 전역 객체(window)를 context 객체로 갖는 것 입니다. 암시적 바인딩 어떤 객체(foo)를 통해 함수가 호출된다면 이때의 의 context 객체는 호출한 어떤 객체(foo)입니다. 첫 번째 코드의 전역 스코프에 위 코드를 추가한다면 의 context 객체는 다시 전역 객체(window)가 됩니다. 전역 스코프에서 생성한 변수는 전역 객체에 등록되기 때문입니다. 명시적 바인딩  메서드는 첫번째 인자로 넘겨주는 것이  context 객체입니다. 이 외에도 ,  메서드를 통해  context 객체를 지정해주는 방식을 명시적 바인딩이라고 합니다. new 바인딩 자바스크…","fields":{"slug":"/javascript/"},"frontmatter":{"categories":"TIL","title":"프로그래머스 과제관 고양이 사진 검색 사이트를 진행하며 사용한 JavaScript","date":"December 03, 2021"}},"next":{"fields":{"slug":"/idea/"}},"previous":{"fields":{"slug":"/feconf/"}}},{"node":{"id":"3fb21fe8-7f12-5c16-8599-7fb9337b29ef","excerpt":"#시작하며\n친구들과 프로젝트를 진행하면서 React Query 를 사용하게 되었습니다. 간단히 찾아보니 api등의 비동기 통신을 도와주는 라이브러리 라는 것으로 파악했습니다. 기존에도 를 사용하여 프로젝트를 진행할 때 여러 비동기 통신을 해보았지만 단순 를 통해 통신하는 것만 경험해보았습니다. 를 살펴보며 왜 써야하는지? 만 사용했을 때와 다른 점은 무엇인지 알아봅시다. 22.02.24 추가 우아한 테크 세미나에서 React Query를 소개한 내용이 있어 추가 정리합니다.  는 웹 서비스 요청에 의한 데이터를 관리하는데 도움을 주는 라이브러리 입니다. 실제 요청은 여전히  또는 를 사용하여 하고, 는 라이프 사이클의 적절한 시간에 요청하는 코드를 호출합니다. 또한 요청에 의한 데이터를 저장해두고, 필요한 때 데이터를 제공합니다. 이 외에도 는 캐싱 및 재요청 같은 수많은 기능을 제공하지만, 가장 큰 장점은 코드를 정리화한다는 것입니다. 사용법 데이터를 가져와야하는 컴포넌트 상위에…","fields":{"slug":"/react-query/"},"frontmatter":{"categories":"TIL","title":"React Query","date":"November 16, 2021"}},"next":{"fields":{"slug":"/react-router-tips/"}},"previous":{"fields":{"slug":"/idea/"}}},{"node":{"id":"20ab402e-3753-5266-9ccd-f088628f4bb1","excerpt":"시작하며 토이프로젝트를 진행하며 React Router 에 대해 알게된 점을 기록해두자 ! 정리   키워드는 정확히 일치 되었을 때만 지정된 컴포넌트를 보여주는 속성이다. 만약  키워드 없이 라우터를 지정한다면 ,  모두 같은 컴포넌트를 렌더링한다. 와의 차이  키워드만으로는 에러가 발생했을 때의 처리가 어렵다. 아래와 같은 라우터가 있을 때 지정되지 않은 url에 접근할 경우  컴포넌트를 렌더링 하지 않는다는 것을 확인할 수 있다. 이 문제를 해결하기 위한 방법으로 나온 것이 이다. 는 첫번째로 매칭되는 를 가진 컴포넌트를 렌더링 시킨다. 이것이 와 다른점이며, 지정되지 않은 url에 접근 시  컴포넌트를 렌더링 시킨다는 것을 확인할 수 있다.   키워드는 trailing slash가 있을 경우에만 일치한다.. 추가로 슬래시 뒤에 URL이 있는 경우엔 영향을 미치지 않는다. path location.path match           키워드와 함께 사용할 경우 이렇게 작동한다.…","fields":{"slug":"/react-router-tips/"},"frontmatter":{"categories":"TIL","title":"사용하면서 배우는 React Router","date":"November 10, 2021"}},"next":{"fields":{"slug":"/recoil/"}},"previous":{"fields":{"slug":"/react-query/"}}},{"node":{"id":"7974cde1-462d-573c-95fa-1747df3ed755","excerpt":"시작하며 니팅 프로젝트를 진행하며 recoil이라는 상태 관리 라이브러리르 처음 사용해보았다. 기존에 구성이 다 잡혀있어서 새로운 상태 추가, 기존에 있던 상태 사용 등의 것들만 해보았는데 프로젝트에서 recoil을 사용하는 방법과 atom, selector에 대한 개념적인 부분이 부족하다고 생각하여 공식문서 를 읽어보았다. Recoil Recoil은 React를 위한 상태관리 라이브러리이다. 작고 React스러운 Recoil은 React처럼 작동하고 생각합니다. 앱에 추가하여 빠르고 유연한 공유되는 상태를 사용해보세요. 데이터 흐름 그래프 파생 데이터와 비동기 쿼리는 순수 함수와 효율적인 구독으로 관리됩니다. 교차하는 앱 관찰 코드 분할을 손상시키지 않고 앱 전체의 모든 상태 변경을 관찰하여 지속성, 라우팅, 시간 이동 디버깅 또는 실행 취소를 구현합니다. 주요 개념 개요 Recoil을 사용하면 atoms(공유 상태)에서 selectors(순수 함수)를 거쳐 React 컴포넌트로…","fields":{"slug":"/recoil/"},"frontmatter":{"categories":"TIL","title":"Recoil","date":"October 27, 2021"}},"next":{"fields":{"slug":"/typescript/"}},"previous":{"fields":{"slug":"/react-router-tips/"}}},{"node":{"id":"64beea0a-fb39-5ee6-9eec-671236695f0b","excerpt":"시작하며 Typescript 3.5 버전에서 이라는 헬퍼타입이 추가되었다. Omit은 빼다 라는 뜻을 가지고 있다. 타입스크립트의 Utility Types 에 보면 Omit 외에도 여러 가지 타입이 있는데,   타입에서  타입을 제거한 새로운 타입을 만드는 타입이다.  ()에서 키 속성 집합(문자열 리터럴 또는 문자열 리터럴 조합 -> , )을 선택하여 새로운 유형을 생성한다.  에서 모든 속성을 선택한 다음 (문자열 리터럴 또는 문자열 리터럴의 조합)을 제거하여 새로운 유형을 생성한다. 마치며 타입스크립트를 처음 사용할 때 일일이 선언해줘야한다는 번거로움이 있었는데 여러 헬퍼타입으로 타입을 재사용할 수 있도록 발전하고 있다. 다른 헬퍼타입들도 공부해두면 여러 번 선언되는 것을 막을 수 있을 것 같다. Refer https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys https://www.youtu…","fields":{"slug":"/typescript/"},"frontmatter":{"categories":"TIL","title":"Typescript 🤙🏻","date":"October 27, 2021"}},"next":{"fields":{"slug":"/react-tips/"}},"previous":{"fields":{"slug":"/recoil/"}}},{"node":{"id":"df1ec505-b699-577c-873a-a019839f9f38","excerpt":"unknown prop 경고 오류코드  원인 React 절대 경로 설정 import 구문을 상대 경로로 지정할 경우 파일이 이동되거나 등의 이벤트가 발생했을 때 오류가 발생할 수 있기 때문에 절대 경로로 변경하여 사용한다. 해결방법 tsconfig.json import문 정렬 import문이 길어질 경우 가독성을 위해 우선순위를 설정하여 정렬한다. eslint-plugin-import 패키지의 을 사용한다. 설치 설정","fields":{"slug":"/react-tips/"},"frontmatter":{"categories":"TIL","title":"React 프로젝트를 진행하며 겪은 어려움과 해결!🧐","date":"October 26, 2021"}},"next":{"fields":{"slug":"/shell-commands/"}},"previous":{"fields":{"slug":"/typescript/"}}},{"node":{"id":"80a67e48-49b7-5862-b221-6684e4ea1101","excerpt":"사용 중인 포트 찾고 kill하기 찾기 kill PID는 찾기 명령어를 통해 알아낼 수 있다.","fields":{"slug":"/shell-commands/"},"frontmatter":{"categories":"TIL","title":"자주 쓰이는 쉘 명령어","date":"October 22, 2021"}},"next":{"fields":{"slug":"/react-native-tips/"}},"previous":{"fields":{"slug":"/react-tips/"}}},{"node":{"id":"0dc2a5fe-3887-5360-b2b9-8fce52467284","excerpt":"시작하며 input 요소의 값이 변경될 때 캐치할 수 있는 이벤트는 과 가 있다. 이 둘의 차이점에 대해 알아보자.  VS   이벤트는  이벤트와 다르게 가 바뀔 때마다 반드시 일어난다. stackoverflow 답변에 더 자세한 차이점을 설명해주고 있다. : 사용자 인터페이스를 통해 텍스트 내용이 변경될 때 발생한다. (텍스트 내용의 변경사항) : 값을 선택하거나 옵션 선택하자마자, 한글 입력의 경우 한글자가 완성된 뒤 다른 키를 입력(예: 엔터 키)이 일어나야 발생된다. , ,  태그에서 사용이 가능하다. : 값의 변경 + 포커스 이동 : 옵션이 변경되었을 때 Ref https://stackoverflow.com/questions/17047497/difference-between-change-and-input-event-for-an-input-element https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/input_event","fields":{"slug":"/input-events/"},"frontmatter":{"categories":"TIL","title":"input change, input 이벤트","date":"October 21, 2021"}},"next":{"fields":{"slug":"/react-native-social-login/"}},"previous":{"fields":{"slug":"/react-native-tips/"}}},{"node":{"id":"d675b500-f66a-5864-983c-14fb24f46e69","excerpt":"시작하며 팀원분께서 현재 내가 참여하고 있는 신규 프로젝트와 기존 구축되어 있던 프로젝트에 AWS 컨테이너 서비스들을 사용하고 Jenkins를 통해 배포를 진행하는 작업을 진행하셨다. 이에 대한 경험을 공유하기 위한 세미나 내용을 정리해보자! 사전설명 ‘이런게 있구나’ 하고 넘어가도 내용 ELB 보다 Cluster가 우선시 된다. ELB TargetGroup이 3개로 지정되어 있어도, Cluster가 2개로 지정되어 있으면 2개의 인스턴스만 사용된다. EC2 인스턴스 안에는 Amazon Agent, Application 두 개의 컨테이너가 있다. Cluster로 지정되지 않은 spare 컨테이너가 N개 존재한다. spare 컨테이너가 많을 수록 성능이 좋을 것으로 예상 spare 컨테이너에서 배포가 시작되는데 1개에서 시작하는 것보다 2개 이상에서 동시에 배포되는 것이 속도가 빠르기 때문. Jenkins 배포 실행 시 spare 컨테이너에 배포가 시작되고, Cluster로 지정된 …","fields":{"slug":"/jenkins/"},"frontmatter":{"categories":"TIL","title":"Jenkins 세미나","date":"October 14, 2021"}},"next":null,"previous":{"fields":{"slug":"/vue-common-js/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}