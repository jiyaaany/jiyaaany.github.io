{"componentChunkName":"component---src-templates-blog-template-js","path":"/animation/","result":{"data":{"cur":{"id":"945b5477-4a7a-57a6-9a2f-3a1cb0b80af6","html":"<h1 id=\"code-classlanguage-texttransitioncode-vs-code-classlanguage-textanimationcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-texttransitioncode-vs-code-classlanguage-textanimationcode\" aria-label=\"code classlanguage texttransitioncode vs code classlanguage textanimationcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">transition</code> VS <code class=\"language-text\">animation</code></h1>\n<p><code class=\"language-text\">transition</code>은 요소의 상태가 변할 때 애니메이션을 실행한다. <code class=\"language-text\">animation</code> 속성은 요소의 모양과 동작을 키프레임 단위로 변경할 수 있다.\n키프레임 동작은 재생 횟수, 방향 등 여러 속성으로 제어할 수 있다.<br>\n가장 큰 차이는 <code class=\"language-text\">transition</code> 은 요소의 상태가 바뀔 때의 상태를 애니메이션으로 표현하지만, <code class=\"language-text\">animation</code> 속성은 요소의 상태 변화와 상관없이\n애니메이션을 실행한다. 또한 <code class=\"language-text\">@keyframse</code> 속성으로 프레임을 추가할 수 있다.</p>\n<p>transition의 예)</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.box</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> 100px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> 100px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">transition</span><span class=\"token punctuation\">:</span> width 2s<span class=\"token punctuation\">,</span> height 2s<span class=\"token punctuation\">;</span> <span class=\"token selector\">// 요소의 상태 변화\n    \n    &amp;:hover</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> 200px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> 200px<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"code-classlanguage-textanimationcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textanimationcode\" aria-label=\"code classlanguage textanimationcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">animation</code></h1>\n<ul>\n<li><code class=\"language-text\">animation-name</code>: <code class=\"language-text\">@keyframes</code> 규칙을 준수 해 정의한 애니메이션 이름</li>\n<li><code class=\"language-text\">animation-duration</code>: 애니메이션이 얼마에 걸쳐 일어날지 결정</li>\n<li><code class=\"language-text\">animation-delay</code>: 로드 이후 어느 정도 텀을 두어 애니메이션이 시작될지 지정</li>\n<li><code class=\"language-text\">animation-direction</code>: 애니메이션의 방향 지정</li>\n<li><code class=\"language-text\">animation-iteration-count</code>: 애니메이션이 몇 번 반복될지 지정 <code class=\"language-text\">infinite</code>로 지정하면 무한반복</li>\n<li><code class=\"language-text\">animation-play-state</code>: 애니메이션을 멈추거나 다시 시작</li>\n<li><code class=\"language-text\">animation-timing-function</code>: 중간 상태들의 전환 간격을 지정</li>\n<li><code class=\"language-text\">animation-fill-mode</code>: 시작되기 전이나 끝나고 난 후 어떤 값이 적용될지 지정</li>\n</ul>\n<h1 id=\"animation의-성능-문제\" style=\"position:relative;\"><a href=\"#animation%EC%9D%98-%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C\" aria-label=\"animation의 성능 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>animation의 성능 문제</h1>\n<ul>\n<li><code class=\"language-text\">margin</code>, <code class=\"language-text\">height</code> 속성은 애니메이션에 사용했을 때 성능 저하를 유발한다.</li>\n<li>윌보이드 - <a href=\"https://www.youtube.com/watch?v=bEoLCZzWZX8\">부드러운 애니메이션 만드는 방법</a>\n<ul>\n<li>부드러운 애니메이션을 적용하려면 <code class=\"language-text\">reflow</code>와 <code class=\"language-text\">repaint</code>를 최소화 시켜야 한다.</li>\n</ul>\n</li>\n<li><a href=\"https://docs.google.com/spreadsheets/u/0/d/1Hvi0nu2wG3oQ51XRHtMv-A_ZlidnwUYwgQsPQUg1R2s/pub?single=true&#x26;gid=0&#x26;output=html\">reflow / repaint가 발생하는 속성</a></li>\n</ul>\n<h2 id=\"reflow를-최소화하는-방법\" style=\"position:relative;\"><a href=\"#reflow%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"reflow를 최소화하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reflow를 최소화하는 방법</h2>\n<ol>\n<li>클래스 변화에 따른 스타일의 변화를 원할 경우, 최대한 DOM 구조 안쪽에 위치한 노드에 추가합니다.</li>\n<li>애니메이션이 들어간 요소는 가급적 <code class=\"language-text\">position: fixed</code> 또는 <code class=\"language-text\">position: absolute</code>로 지정합니다.\n<ul>\n<li>다른 요소에는 영향을 끼치지 않으므로 해당 요소만 reflow가 발생합니다.</li>\n</ul>\n</li>\n<li>JS를 통해 스타일 변화를 줄 경우, 가급적 한번에 처리합니다.</li>\n<li>인라인 스타일을 최대한 배제합니다.</li>\n<li>테이블 레이아웃을 피하는 것이 좋습니다.</li>\n</ol>\n<ul>\n<li>테이블 레이아웃은 넓이를 계산하면서 렌더링이 느려집니다. 꼭 필요한 경우를 제외하곤 테이블 레이아웃을 사용하지 않는 것이 좋습니다. 만약 사용한다면 CSS 속성</li>\n</ul>\n<p><code class=\"language-text\">table-layout: fixed</code>를 사용하면 조금 더 빠르게 렌더링 할 수 있습니다.\n6. CSS 하위선택자는 필요한 만큼 정리하는 것이 좋습니다.</p>\n<p>변경을 미리 감지하여 알려주는 <a href=\"https://wit.nts-corp.com/2017/06/05/4571\">will-change</a> 방법도 있는데 이건 나중에 봐야지 ..<br>\n애니메이션 키프레임의 경우 CPU를 많이 사용하여 자칫 부하를 가져다줄 수 있는데 다른 방법으로 GPU를 사용하도록 유도할 수 있다. <a href=\"http://daplus.net/css-css-%ED%82%A4-%ED%94%84%EB%A0%88%EC%9E%84-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-cpu-%EC%82%AC%EC%9A%A9%EB%9F%89%EC%9D%B4-%EB%86%92%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%9D%B4%EB%A0%87%EA%B2%8C/\">링크</a></p>\n<h1 id=\"ref\" style=\"position:relative;\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ref</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions\">https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions</a>\n<a href=\"https://webclub.tistory.com/621\">https://webclub.tistory.com/621</a>\n<a href=\"https://wit.nts-corp.com/2017/06/05/4571\">https://wit.nts-corp.com/2017/06/05/4571</a>\n<a href=\"http://daplus.net/css-css-%ED%82%A4-%ED%94%84%EB%A0%88%EC%9E%84-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-cpu-%EC%82%AC%EC%9A%A9%EB%9F%89%EC%9D%B4-%EB%86%92%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%9D%B4%EB%A0%87%EA%B2%8C/\">http://daplus.net/css-css-%ED%82%A4-%ED%94%84%EB%A0%88%EC%9E%84-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-cpu-%EC%82%AC%EC%9A%A9%EB%9F%89%EC%9D%B4-%EB%86%92%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%9D%B4%EB%A0%87%EA%B2%8C/</a></p>","excerpt":"VS  은 요소의 상태가 변할 때 애니메이션을 실행한다.  속성은 요소의 모양과 동작을 키프레임 단위로 변경할 수 있다.\n키프레임 동작은 재생 횟수, 방향 등 여러 속성으로 제어할 수 있다. 가장 큰 차이는  은 요소의 상태가 바뀔 때의 상태를 애니메이션으로 표현하지만,  속성은 요소의 상태 변화와 상관없이\n애니메이션을 실행한다. 또한  속성으로 프레임을 추가할 수 있다. transition의 예)  :  규칙을 준수 해 정의한 애니메이션 이름 : 애니메이션이 얼마에 걸쳐 일어날지 결정 : 로드 이후 어느 정도 텀을 두어 애니메이션이 시작될지 지정 : 애니메이션의 방향 지정 : 애니메이션이 몇 번 반복될지 지정 로 지정하면 무한반복 : 애니메이션을 멈추거나 다시 시작 : 중간 상태들의 전환 간격을 지정 : 시작되기 전이나 끝나고 난 후 어떤 값이 적용될지 지정 animation의 성능 문제 ,  속성은 애니메이션에 사용했을 때 성능 저하를 유발한다. 윌보이드 - 부드러운 애니메이션…","frontmatter":{"date":"May 04, 2022","title":"CSS 애니메이션","categories":"TIL","author":"지걸","emoji":"🙈"},"fields":{"slug":"/animation/"}},"next":{"id":"8d8b7c71-c74f-5a98-b188-215a6c81f0d8","html":"<h1 id=\"알고리즘\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘</h1>\n<p><strong>시간 복잡도</strong>: 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석\n<strong>공간 복잡도</strong>: 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석<br>\n빅오 표기법(Big-O Notation): 복잡도를 나타내기 위한 표기 방법</p>\n<ul>\n<li><code class=\"language-text\">가장 빠르게 증가하는 항</code> 만 고려한다.</li>\n<li>ex. 3N^3 + 5N^2 + 1,000,000 일 때, 빅오 표기법에서는 차수가 가장 큰 O(N^3)으로 표현</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 609px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8klEQVQoz31SiW7aQBT0//9H+gdNS1IECBCYG6FylduAvcYHtoM5DEw0L4KEqupK4337jtl5z6sBwGq1wnQ6hWVZCIKALvTsEK9dA+VlAH0dQTe2SP+eybmyfkN5FUIXRCgaIQZuLHUaP9vtFpvNBr7vY7fbSaBmeHgq9ZAaufg1C/BzqPCt0MH3vsKPPw5eJj5exj5eJz6eRx5a1tsH4fV6FeN8Pgu4xHM5Iwq2uCQn8R33MQLfh2Mr2OYajrLg2grKXCP0vY+66/WTcL/f43A44LZOp5OoJg6Hoyh3XRf2ZiOjUcqGaVoSS5JPMXdCkh2PxzthkiRQloLv+VJAQtM0Ya5NGU0URQjDUC7+2t1/CamIPubE8U4uoDrm0kdcLhch437/Kf8ipK0sC4vFAp7niSLbtjGfzzGbzcTHS6mQoC2EPLCY8llEm2CLSikp5Hz5EtgynxhzKSCO4zuYQ5Ua3x0Hv1wuJdlxHAFbGw4GoojKDMNAv99Ht9uVXPp44VdQpcbCWxt83GyR9ng0QrvdRq/XEz/3RqMhGA6HmEwmGI/HDzs701iczWaRSqWQy+VQLBbR6XSkMJPJoFwuC7Gu6xJPp9OoVCpotVpoNpsPYOsamQuFgiTn83mUSiVJrtfrqFarqNVqD7j5GP87xrm/A76mfRB9QlxoAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img_1.png\"\n        title=\"img_1.png\"\n        src=\"/static/bb67b8edd9ef8333790fa717d42339e3/d0d8c/img_1.png\"\n        srcset=\"/static/bb67b8edd9ef8333790fa717d42339e3/e9ff0/img_1.png 180w,\n/static/bb67b8edd9ef8333790fa717d42339e3/f21e7/img_1.png 360w,\n/static/bb67b8edd9ef8333790fa717d42339e3/d0d8c/img_1.png 609w\"\n        sizes=\"(max-width: 609px) 100vw, 609px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1 id=\"dynamic-programming\" style=\"position:relative;\"><a href=\"#dynamic-programming\" aria-label=\"dynamic programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Programming</h1>\n<h2 id=\"메모이제이션-memoization\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-memoization\" aria-label=\"메모이제이션 memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모이제이션 (Memoization)</h2>\n<p>메모이제이션은 탑다운 방식에서 사용됩니다. 한 번 계산된 결과를 메모리 공간에 저장하는 기법입니다.</p>\n<ul>\n<li>같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.</li>\n<li>값을 기록해 놓는다는 점에서 <strong>캐싱(Caching)</strong> 이라고도 합니다.</li>\n</ul>\n<h2 id=\"탑다운-vs-보텀업\" style=\"position:relative;\"><a href=\"#%ED%83%91%EB%8B%A4%EC%9A%B4-vs-%EB%B3%B4%ED%85%80%EC%97%85\" aria-label=\"탑다운 vs 보텀업 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>탑다운 VS 보텀업</h2>\n<ul>\n<li>탑다운(메모이제이션) 방식은 <strong>하향식</strong>이라고도 하며 보톰업 방식은 <strong>상향식</strong>이라고도 합니다.</li>\n<li>다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식입니다.\n<ul>\n<li>결과 저장용 리스트는 DP 테이블이라고 부릅니다.</li>\n</ul>\n</li>\n<li>엄밀히 말하면 메모이제이션은 <strong>이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미</strong>합니다.\n<ul>\n<li>따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.</li>\n<li>한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"다이나믹-프로그래밍-vs-분할-정복\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-vs-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5\" aria-label=\"다이나믹 프로그래밍 vs 분할 정복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다이나믹 프로그래밍 VS 분할 정복</h2>\n<ul>\n<li>다이나믹 프로그래밍과 분할 정복은 모두 <strong>최적 부분 구조</strong>를 가질 때 사용할 수 있습니다.\n<ul>\n<li>큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황</li>\n</ul>\n</li>\n<li>다이나믹 프로그래밍과 분할 정복의 차이점은 <strong>부분 문제의 중복</strong>입니다.\n<ul>\n<li>다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.</li>\n<li>분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.\n<ul>\n<li><strong>분할 정복</strong>의 대표적인 예시인 퀵 정렬을 살펴봅시다.\n<ul>\n<li>한번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않습니다.</li>\n<li>분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않습니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"다이나믹-프로그래밍-문제에-접근하는-방법\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EC%A0%9C%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"다이나믹 프로그래밍 문제에 접근하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다이나믹 프로그래밍 문제에 접근하는 방법</h2>\n<ul>\n<li>주어진 문제가 <strong>다이나믹 프로그래밍 유형임을 파악</strong>하는 것이 중요합니다.</li>\n<li>가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있습니다.\n<ul>\n<li>다른 알고리즘으로 풀이 방법이 떠오르지 않다면 다이나믹 프로그래밍을 고려해 봅시다.</li>\n</ul>\n</li>\n<li>일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있습니다.</li>\n<li>일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많습니다.</li>\n</ul>\n<h1 id=\"완전탐색-exhaustive-search\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-exhaustive-search\" aria-label=\"완전탐색 exhaustive search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완전탐색 (Exhaustive Search)</h1>\n<ul>\n<li>모든 경우의 수를 시도해보는 방법</li>\n<li>상대적으로 구현이 간단하 해가 존재한다면 항상 찾게 됨</li>\n<li>경우의 수에 따라 실행 시간이 비례하기 때문에 입력 값의 범위가 작은 경우에 유용</li>\n</ul>\n<h1 id=\"dfs--bfs\" style=\"position:relative;\"><a href=\"#dfs--bfs\" aria-label=\"dfs  bfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DFS &#x26; BFS</h1>\n<ul>\n<li>대표적인 그래프 탐색 알고리즘</li>\n<li>탐색(Search)이란 많은 양의 데이터 중 원하는 데이터를 찾는 과정을 말함</li>\n</ul>\n<h2 id=\"dfs-depth-first-search\" style=\"position:relative;\"><a href=\"#dfs-depth-first-search\" aria-label=\"dfs depth first search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DFS (Depth-First-Search)</h2>\n<ul>\n<li>깊이 우선 탐색, 그래프에서 가장 깊은 부분을 우선적으로 탐색</li>\n<li>DFS는 스택 자료구조 (혹은 재귀함수)를 이용</li>\n</ul>\n<h2 id=\"bfs-breadth-first-search\" style=\"position:relative;\"><a href=\"#bfs-breadth-first-search\" aria-label=\"bfs breadth first search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BFS (Breadth-First-Search)</h2>\n<ul>\n<li>너비 우선 탐색, 그래프에서 가장 가까운 노드부터 탐색</li>\n<li>BFS는 큐 자료구조 사용 (ex. 최단거리 문제에서 자주 사용)</li>\n</ul>\n<h1 id=\"스택-자료구조\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"스택 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택 자료구조</h1>\n<ul>\n<li>먼저 들어온 데이터가 나중에 나가는 형식(선입후출 LIFO)</li>\n<li>입구와 출구가 동일</li>\n</ul>\n<h1 id=\"큐-자료구조\" style=\"position:relative;\"><a href=\"#%ED%81%90-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"큐 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐 자료구조</h1>\n<ul>\n<li>먼저 들어온 데이터가 먼저 나가는 형식(선입선출 FIFO)</li>\n<li>입구와 출구가 모두 뚫려 있는 터널과 같은 형태</li>\n</ul>\n<h1 id=\"유클리드-호제법\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95\" aria-label=\"유클리드 호제법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유클리드 호제법</h1>\n<ul>\n<li>두개의 최대 공약수를 구하는 대표적인 알고리즘</li>\n<li>두 자연수 A, B에 대하여 (A > B) A를 B로 나눈 나머지를 R이라고 합시다.</li>\n<li>이때 A와 B의 최대공약수는 B와 R의 최대공약수와 같습니다.</li>\n</ul>\n<h1 id=\"정렬\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC\" aria-label=\"정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정렬</h1>\n<ul>\n<li>정렬(Sorting)이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것</li>\n<li>문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용됨</li>\n</ul>\n<h2 id=\"선택-정렬\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC\" aria-label=\"선택 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선택 정렬</h2>\n<ul>\n<li>처리되지 않은 데이터 중 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복</li>\n<li>시간 복잡도: O(N^2)</li>\n</ul>\n<h2 id=\"삽입-정렬\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC\" aria-label=\"삽입 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입 정렬</h2>\n<ul>\n<li>처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입</li>\n<li>선택 정렬에 비해 구현하기 어렵지만 일반적으로 보다 효율적</li>\n</ul>\n<h2 id=\"순차탐색-sequential-search\" style=\"position:relative;\"><a href=\"#%EC%88%9C%EC%B0%A8%ED%83%90%EC%83%89-sequential-search\" aria-label=\"순차탐색 sequential search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순차탐색 (Sequential Search)</h2>\n<p>순차탐색은 어떠한 값을 찾고자 할 때 하나씩 비교해보는 방법을 말합니다.</p>\n<h2 id=\"이진탐색\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89\" aria-label=\"이진탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진탐색</h2>\n<p>이진탐색은 범위의 중간 값을 찾아 찾으려는 값과 비교하여 범위를 좁혀나가는 방법을 말합니다.</p>\n<blockquote>\n<p>이진탐색의 경우 정렬이 잘 되어있는 경우 사용할 수 있습니다.</p>\n</blockquote>\n<h1 id=\"탐욕법\" style=\"position:relative;\"><a href=\"#%ED%83%90%EC%9A%95%EB%B2%95\" aria-label=\"탐욕법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>탐욕법</h1>\n<p>그리디 알고리즘이란 현재 상황에서 가장 좋은 최선의 선택을 고르는 알고리즘을 말합니다. 그리디 알고리즘은 간단한 문제 해결에 다이나믹 프로그래밍을 사용하면 지나치게 많은 일을 한다는 것에서 고안된 알고리즘입니다. 따라서 그리디 알고리즘은 최적해를 보장하지는 않습니다.</p>\n<h1 id=\"구현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-label=\"구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현</h1>\n<p>구현이란 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정입니다.</p>\n<ul>\n<li>알고리즘은 간단한데 코드가 길어지는 문제</li>\n<li>실수 연산을 다루고 특정 소수점까지 출력해야하는 문제</li>\n<li>문자열을 특정한 기준에 따라 끊어 처리해야하는 문제</li>\n<li>적절한 라이브러리를 찾아 사용해야하는 문제</li>\n</ul>\n<h1 id=\"해시-hash\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-hash\" aria-label=\"해시 hash permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 (Hash)</h1>\n<ul>\n<li>임의의 크기를 가진 데이터(Key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것</li>\n<li>키에 대한 해시 값을 사용하여 값을 저장하고 키-값 쌍의 갯수에 따라 동적으로 크기가 증가하는 연관 배열</li>\n<li>키에 대한 해시 값을 구하는 과정을 해싱(Hashing)이라고 하며 이때 사용하는 함수(알고리즘) 해시 함수(Hash Function)이라고 한다.</li>\n<li>해시 값 자체를 index로 사용하기 때문에 평균 시간 복잡도가 O(1)로 매우 빠름</li>\n</ul>\n<blockquote>\n<p><strong>연관 배열?</strong><br>\n<strong>연관 배열</strong>(associative array)은 자료구조의 하나로, 키 하나와 값 하나가 연관되어 있으며 키를 통해 연관되는 값을 얻을 수 있다.</p>\n</blockquote>\n<h2 id=\"해시-함수-hash-function\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-hash-function\" aria-label=\"해시 함수 hash function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 함수 (Hash Function)</h2>\n<ul>\n<li>임의의 길이의 데이터를 입력받아 일정한 길이의 비트열로 반환시켜주는 함수</li>\n<li>원래의 값이나 키를 색인하는데 사용되며, 그 값이 관련된 데이터가 검색될 때마다 다시 사용된다.</li>\n<li>데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수</li>\n<li>계산이 복잡하지 않고 중복 키 값 없이 해시값을 고르게 만드는 함수가 좋다. (충돌이 일어나지 않을수록)</li>\n<li>문자열(string)을 받아서 숫자를 반환하는 함수 (함수는 문자열에 대해 숫자를 매핑)</li>\n</ul>\n<h2 id=\"해싱-hashing\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%B1-hashing\" aria-label=\"해싱 hashing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해싱 (Hashing)</h2>\n<ul>\n<li>키 값에 산술 연산을 적용하여 저장되어 있는 테이블의 주소를 계산하여 항목에 접근</li>\n<li>매핑하는 과정을 말한다.</li>\n<li>키(key): 매핑 전 원래 데이터 값</li>\n<li>해시값: 매핑 후 데이터</li>\n</ul>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<ul>\n<li>해시 충돌이 발생할 가능성이 있지만, 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있음</li>\n<li>index에 해시 값을 사용하므로 모든 데이터를 살피지 않아도 검색과 삽입/삭제를 빠르게 수행</li>\n<li>해시 함수는 언제나 동일한 해시 값을 리턴하고 index만 알면 해시 테이블의 크기와 상관없이 데이터에 빠르게 접근 가능</li>\n<li>데이터 엑세스(삽입, 삭제, 탐색)시 시간 복잡도 O(1)을 지향한다.</li>\n</ul>\n<h2 id=\"refer\" style=\"position:relative;\"><a href=\"#refer\" aria-label=\"refer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refer</h2>\n<p><a href=\"https://coding-sojin2.tistory.com/entry/%ED%95%B4%EC%8B%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-hash-algorithm\">https://coding-sojin2.tistory.com/entry/%ED%95%B4%EC%8B%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-hash-algorithm</a></p>","frontmatter":{"date":"March 30, 2022","title":"알고리즘 공부","categories":"algorithm","author":"지걸","emoji":"😌"},"fields":{"slug":"/algorithm/"}},"prev":{"id":"c2bff4e9-1e69-5f70-94af-5214e90034fd","html":"<h1 id=\"링크-모음집\" style=\"position:relative;\"><a href=\"#%EB%A7%81%ED%81%AC-%EB%AA%A8%EC%9D%8C%EC%A7%91\" aria-label=\"링크 모음집 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>링크 모음집</h1>\n<p><a href=\"https://auth0.com/blog/url-uri-urn-differences/\">URL, URI, URN의 차이</a></p>","frontmatter":{"date":"May 24, 2022","title":"link 모음집","categories":"TIL","author":"지걸","emoji":"🙈"},"fields":{"slug":"/link/"}},"site":{"siteMetadata":{"siteUrl":"https://jiyaaany.netlify.app","comments":{"utterances":{"repo":"jiyaaany/jiyaaany.github.io"}}}}},"pageContext":{"slug":"/animation/","nextSlug":"/algorithm/","prevSlug":"/link/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}