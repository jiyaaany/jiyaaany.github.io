{"componentChunkName":"component---src-templates-blog-template-js","path":"/css-wiki/","result":{"data":{"cur":{"id":"f2b3c110-e07b-5a61-ba58-a4f50a58a292","html":"<h1 id=\"마진-상쇄-margin-collapsing\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%A7%84-%EC%83%81%EC%87%84-margin-collapsing\" aria-label=\"마진 상쇄 margin collapsing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마진 상쇄 (Margin-collapsing)</h1>\n<blockquote>\n<p>MDN<br>\n블록의 top 및 bottom 마진은 때로 결합되는 마진 중 크기가\n가장 큰 마진으로 결합(combine, 상쇄(collapsed)) 됩니다.</p>\n</blockquote>\n<p>어떤 두 개의 블록 요소의 상하 마진이 겹칠 때 한 쪽의 값만 적용되는 현상이다.</p>\n<h2 id=\"마진-상쇄가-일어나는-상황\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%A7%84-%EC%83%81%EC%87%84%EA%B0%80-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%83%81%ED%99%A9\" aria-label=\"마진 상쇄가 일어나는 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마진 상쇄가 일어나는 상황</h2>\n<ol>\n<li>인접 형제 박스 간 상하 마진이 겹칠 때</li>\n</ol>\n<p>겹쳐진 두 마진 중 더 큰 마진 값으로 상쇄해 렌더링한다.\n2. 빈 요소의 상하 마진이 겹칠 때<br>\n‘빈 요소’란 높이(height)가 0인 상태의 요소를 말한다.</p>\n<ul>\n<li>height / min-height / padding / border 등 상하로 늘어나는 값을 명시적으로 주지 않을 경우</li>\n<li>내부에 Inline 콘텐츠가 존재하지 않는 요소</li>\n</ul>\n<ol start=\"3\">\n<li>부모 박스와 첫 번째 자식 박수의 마진이 겹칠 때</li>\n</ol>\n<p>그래서 이럴 경우 부모 박스에 padding을 주어 간격을 유지하는 것이 안전하다.</p>\n<h2 id=\"마진-상쇄-규칙\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%A7%84-%EC%83%81%EC%87%84-%EA%B7%9C%EC%B9%99\" aria-label=\"마진 상쇄 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마진 상쇄 규칙</h2>\n<ul>\n<li>마진 상쇄는 인접한 두 요소가 온전한 <strong>block-level</strong> 요소일 때만 적용<br>\n(inline, inline-block, table-cell, table-caption 요소는 block-level이 아님)</li>\n<li>마진 값이 0이더라도 상쇄 규칙은 적용</li>\n<li>좌우 마진은 겹치더라도 상쇄 X</li>\n</ul>\n<h2 id=\"마진-상쇄-규칙-예외\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%A7%84-%EC%83%81%EC%87%84-%EA%B7%9C%EC%B9%99-%EC%98%88%EC%99%B8\" aria-label=\"마진 상쇄 규칙 예외 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마진 상쇄 규칙 예외</h2>\n<ul>\n<li><code class=\"language-text\">position: absolute</code></li>\n<li><code class=\"language-text\">float: left / right</code> (단, clear 되지 않은 상태)</li>\n<li><code class=\"language-text\">display: flex</code> 일 때 내부 flex box item</li>\n<li><code class=\"language-text\">display: grid</code> 일 때 내부 grid item</li>\n</ul>","excerpt":"마진 상쇄 (Margin-collapsing) MDN 블록의 top 및 bottom 마진은 때로 결합되는 마진 중 크기가\n가장 큰 마진으로 결합(combine, 상쇄(collapsed)) 됩니다. 어떤 두 개의 블록 요소의 상하 마진이 겹칠 때 한 쪽의 값만 적용되는 현상이다. 마진 상쇄가 일어나는 상황 인접 형제 박스 간 상하 마진이 겹칠 때 겹쳐진 두 마진 중 더 큰 마진 값으로 상쇄해 렌더링한다.\n2. 빈 요소의 상하 마진이 겹칠 때 ‘빈 요소’란 높이(height)가 0인 상태의 요소를 말한다. height / min-height / padding / border 등 상하로 늘어나는 값을 명시적으로 주지 않을 경우 내부에 Inline 콘텐츠가 존재하지 않는 요소 부모 박스와 첫 번째 자식 박수의 마진이 겹칠 때 그래서 이럴 경우 부모 박스에 padding을 주어 간격을 유지하는 것이 안전하다. 마진 상쇄 규칙 마진 상쇄는 인접한 두 요소가 온전한 block-level 요소일…","frontmatter":{"date":"December 16, 2022","title":"CSS 백과사전 📚","categories":"CSS","author":"지걸","emoji":"💬"},"fields":{"slug":"/css-wiki/"}},"next":{"id":"e0d6b361-0548-5c13-9317-f3af8fd11e22","html":"<h1 id=\"함수-표현식-vs-함수-선언식\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D-vs-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EC%8B%9D\" aria-label=\"함수 표현식 vs 함수 선언식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 표현식 VS 함수 선언식</h1>\n<p>함수 선언식 (function declartion)은 별도의 할당 없이 함수만 정의된 형태</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>함수 표현식 (function Expression)은 정의된 함수를 변수에 할당하는 형태</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 둘의 주요 차이점은 호이스팅(hoisting)이다. 함수 선언식은 함수 전체가 호이스팅 되기 때문에\n함수 선언 전에 함수를 사용할 수 있다. 반면 함수 표현식은 별도의 변수에 할당하는 형태라\n변수의 선언부만 호이스팅하게 된다.</p>\n<h1 id=\"실행-컨텍스트-execution-context\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-execution-context\" aria-label=\"실행 컨텍스트 execution context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 컨텍스트 (Execution Context)</h1>\n<p>자바스크립트 코드를 실행하기 위해 필요한 환경이 제공되는 범위</p>","frontmatter":{"date":"December 16, 2022","title":"JS 백과사전 📚","categories":"Javascript","author":"지걸","emoji":"💬"},"fields":{"slug":"/js-wiki/"}},"prev":{"id":"13699728-3d43-506a-94a0-64875ca0d7ae","html":"<h1 id=\"getting-started-시작하기\" style=\"position:relative;\"><a href=\"#getting-started-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"getting started 시작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Getting Started (시작하기)</h1>\n<p>애플리케이션 루트 경로에 <code class=\"language-text\">pages</code>와 <code class=\"language-text\">public</code> 디렉토리가 생성된다.</p>\n<ul>\n<li><code class=\"language-text\">pages</code>: 디렉토리 내부의 파일 명은 라우터와 연결된다. 예를 들어, <code class=\"language-text\">pages/about.js</code>는 <code class=\"language-text\">/about</code> 과 매핑된다.</li>\n<li><code class=\"language-text\">public</code>: 이미지, 폰트 등 정적 리소스를 저장한다. <code class=\"language-text\">public</code> 폴더 안 파일들은 base URL(<code class=\"language-text\">/</code>)으로 코드가 실행되기 전에 참조할 수 있다.</li>\n</ul>\n<p>Next.js는 페이지 개념을 중심으로 만들어졌다. 페이지란 <code class=\"language-text\">pages</code> 디렉토리 내부의 <code class=\"language-text\">.js</code>, <code class=\"language-text\">.jsx</code>, <code class=\"language-text\">.ts</code>, or <code class=\"language-text\">.tsx</code> 타입의 리액트 컴포넌트를 말한다.\n뿐만 아니라 파일 이름을 통해 <a href=\"https://nextjs.org/docs/routing/dynamic-routes\">dynamic route</a> 파라미터를 설정할 수 있다.</p>\n<p><code class=\"language-text\">pages</code> 디렉토리 안의 <code class=\"language-text\">index.js</code> 파일은 시작을 위한 파일이다. 사용자가 애플리케이션을 방문했을 때 렌더링 되는 페이지이다.</p>\n<p>지금까지 우리는:</p>\n<ul>\n<li>자동 컴파일과 <a href=\"https://nextjs.org/docs/advanced-features/compiler\">번들링</a></li>\n<li><a href=\"https://nextjs.org/blog/next-9-4#fast-refresh\">React Fast Refresh</a></li>\n<li><code class=\"language-text\">pages/</code>의 <a href=\"https://nextjs.org/docs/basic-features/data-fetching/overview\">정적 generation 및 서버 사이드 렌더링</a></li>\n<li>base URL과 매핑되는 <code class=\"language-text\">public/</code> 디렉토리를 통한 <a href=\"https://nextjs.org/docs/basic-features/static-file-serving\">정적 파일 제공</a></li>\n</ul>\n<h1 id=\"basic-features-기본적인-기능\" style=\"position:relative;\"><a href=\"#basic-features-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5\" aria-label=\"basic features 기본적인 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Basic Features (기본적인 기능)</h1>\n<h2 id=\"pages\" style=\"position:relative;\"><a href=\"#pages\" aria-label=\"pages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pages</h2>\n<p><code class=\"language-text\">pages/</code> 디렉토리의 각 페이지는 파일 이름을 기반으로 라우터와 연결된다.</p>\n<p><strong>예</strong>: <code class=\"language-text\">pages/about.js</code> 리액트 컴포넌트를 만들었다면 그것은 <code class=\"language-text\">/about</code>으로 접근할 수 있다.</p>\n<h3 id=\"pages-with-dynamic-routes\" style=\"position:relative;\"><a href=\"#pages-with-dynamic-routes\" aria-label=\"pages with dynamic routes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pages with Dynamic Routes</h3>\n<p>Next.js는 동적 라우팅 페이지를 지원한다. 예를 들어, <code class=\"language-text\">pages/posts/[id].js</code> 파일을 만들었다면,\n그것은 <code class=\"language-text\">posts/1</code>, <code class=\"language-text\">posts/2</code> 등으로 접근이 가능할 수 있다.</p>\n<h3 id=\"pre-rendering\" style=\"position:relative;\"><a href=\"#pre-rendering\" aria-label=\"pre rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pre-rendering</h3>\n<p>기본적으로, Next.js는 모든 페이지를 미리 렌더링한다. 이것은 Next.js는 client-side에서 모든 것을 수행하는게 아니라\n미리 각 페이지의 HTML을 생성한다는 의미이다. Pre-rendering은 성능과 SEO 측면에서 더 나은 결과를 가져올 수 있다.</p>\n<p>생성된 각 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연관되어 있다. 브라우저로부터 해당 페이지를 요청 받았을 때,\n자바스크립트 코드가 실행되면서 페이지를 완전히 상호작용하게 만든다. (이 프로세스를 <em>hydration</em>이라고 함.)</p>\n<h3 id=\"pre-rendering의-두가지-형태\" style=\"position:relative;\"><a href=\"#pre-rendering%EC%9D%98-%EB%91%90%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C\" aria-label=\"pre rendering의 두가지 형태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pre-rendering의 두가지 형태</h3>\n<p>Next.js는 pre-rendering의 두가지 형태를 갖고있다: <strong>Static Generation</strong>과 <strong>Server-side Rendering</strong>.\n이것은 <strong>언제</strong> HTML을 생성하는지에 차이가 있다.</p>\n<ul>\n<li>Static Generation (추천): HTML이 <strong>빌드</strong>될 때 생성되어 각 요청에 의해 재사용된다.</li>\n<li>Server-side Rendering: HTML이 각 요청 때 생성된다.</li>\n</ul>\n<p>중요한건, Next.js는 각 페이지를 어떻게 사용할지에 따라 pre-rendering 을 선택적으로 사용할 수 있다.\n다수의 페이지를 위한 Static Generation과 그 외의 페이지들을 위한 Server-side Rendering을 동시에 사용하는 “hybrid” Next.js 앱을 만들 수 있다.</p>\n<p>성능상의 이유로 Server-side Rendering 보다는 <strong>Static Generation</strong> 사용을 추천한다. 정적으로 생성된 페이지는\n별도의 구성 없이 CDN으로부터 캐싱되어 성능을 향상시킬 수 있다. 그러나 경우에 따라 Server-side Rendering만 사용해야할 수 있다.</p>\n<p>Static Generation 또는 Server-side Rendering과 함께 Client-side data fetching 또한 사용할 수 있다.\n무조건 클라이언트 측 자바스크립트에서 렌더링 되어야하는 페이지의 경우를 뜻한다.</p>\n<h2 id=\"static-generation\" style=\"position:relative;\"><a href=\"#static-generation\" aria-label=\"static generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Generation</h2>\n<p>Static Generation을 사용하는 페이지라면, 해당 페이지의 HTML은 빌드 시에 생성된다. <code class=\"language-text\">next build</code> 명령어를 실행했을 때 HTML이 생성된다는 뜻이다.\nHTML은 각 요청 시에 재사용된다. 이것 또한 CDN을 통해 캐싱된다.</p>\n<p>Next.js에서는 데이터의 유무와 상관없이 정적으로 페이지를 생성할 수 있다.</p>\n<h3 id=\"static-generation-without-data\" style=\"position:relative;\"><a href=\"#static-generation-without-data\" aria-label=\"static generation without data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Generation without data</h3>\n<p>기본적으로, Next.js는 데이터를 가져오지 않고 Static Generation을 사용하여 pre-render 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">About</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>About<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> About</code></pre></div>\n<p>이 페이지는 사전에 렌더링 될 때 외부 데이터를 가져올 필요가 없다. 이러한 경우 Next.js는 HTML 페이지를 빌드 시에 생성한다.</p>\n<h3 id=\"static-generation-with-data\" style=\"position:relative;\"><a href=\"#static-generation-with-data\" aria-label=\"static generation with data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Generation with data</h3>\n<p>몇몇 페이지들은 pre-rendering을 위한 외부 데이터를 가져와야하는 경우가 있다.\n이러한 경우 Next.js에서 제공되는 두가지 함수를 사용할 수 있다:</p>\n<ol>\n<li>외부 데이터가 <strong>페이지 내용</strong>과 의존되는 경우: <code class=\"language-text\">getStaticProps</code></li>\n<li>외부 데이터가 <strong>경로</strong>와 의존되는 경우: <code class=\"language-text\">getStaticPaths</code> (일반적으로 <code class=\"language-text\">getStaticProps</code>와 함께 사용)</li>\n</ol>\n<p><strong>예</strong>: 블로그에서 글 목록을 가져오는 경우</p>\n<p>사전 렌더 시 데이터를 가져오기 위해 Next.js는 동일한 파일에서 <code class=\"language-text\">getStaticProps</code> 비동기 함수를 <code class=\"language-text\">export</code> 한다.\n이 함수는 빌드 타임 때 호출되며 사전 렌더링 시 가져온 데이터를 page의 <code class=\"language-text\">props</code>로 전달한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Blog</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> posts <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> posts <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            posts<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><code class=\"language-text\">getStaticPaths()</code></strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticPaths</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> posts <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">const</span> paths <span class=\"token operator\">=</span> posts<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">post</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">params</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> posts<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> paths<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">fallback</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"언제-static-generation을-사용해야할까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-static-generation%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"언제 static generation을 사용해야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 Static Generation을 사용해야할까?</h3>\n<p>언제든 가능하다면 <strong>Static Generation(데이터가 있든 없든)</strong> 을 사용하는 것을 권장한다.\n왜냐하면 페이지는 한번 빌드되고 CDN으로부터 제공되기 때문에 모든 요청을 서버가 렌더링 해주는 것보다 더욱 빠르다.</p>\n<h1 id=\"server-side-rendering\" style=\"position:relative;\"><a href=\"#server-side-rendering\" aria-label=\"server side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server-side Rendering</h1>\n<p>Server-side Rendering을 사용하기 위해서는 <code class=\"language-text\">getServerSideProps</code> 비동기 함수를 <code class=\"language-text\">export</code> 해야 한다.\n이 함수는 매 요청마다 서버로부터 호출된다.</p>\n<p>예를 들어, 페이지에서 자주 업데이트 되는 데이터를 렌더링해야 한다고 가정해보면 아래와 같이 <code class=\"language-text\">Page</code>에 전달하는\n<code class=\"language-text\">getServerSideProps</code>를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Page</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getServerSideProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>보는 것과 같이 <code class=\"language-text\">getServerSideProps</code>는 <code class=\"language-text\">getStaticProps</code>와 비슷하다. 그러나 다른 점은 <code class=\"language-text\">getServerSideProps</code>는\n빌드 때만 호출되는게 아니라 매 요청마다 호출된다는 점이다.</p>\n<h1 id=\"data-fetching-overview-데이터-가져오기-개요\" style=\"position:relative;\"><a href=\"#data-fetching-overview-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0-%EA%B0%9C%EC%9A%94\" aria-label=\"data fetching overview 데이터 가져오기 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data Fetching Overview (데이터 가져오기 개요)</h1>\n<p>Next.js에서 데이터 가져오기를 사용하면 애플리케이션에 따라 다양한 방법으로 콘텐츠를 렌더링할 수 있다.\n<strong>Server-side Rendering</strong> 또는 <strong>Static Generation</strong> 과 같은 pre-rendering을 포함하고\n런타임 시 수정 또는 콘텐츠 생성을 위한 Incremental Static Regeneration이 있다.</p>\n<h2 id=\"getserversideprops\" style=\"position:relative;\"><a href=\"#getserversideprops\" aria-label=\"getserversideprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>getServerSideProps</h2>\n<p>만약 페이지로부터 <code class=\"language-text\">getServerSideProps</code>(Server-Side Rendering) 가 호출된다면 Next.js는\n<code class=\"language-text\">getServerSideProps</code>에서 반환된 데이터를 사용하여 각 요청을 위한 페이지를 미리 렌더링한다.</p>\n<p><code class=\"language-text\">getServerSideProps</code>는 오직 페이지에서만 사용할 수 있다. page가 아닌 파일에서는 사용할 수 없다.</p>\n<h3 id=\"언제-getserversideprops를-사용해야-할까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-getserversideprops%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"언제 getserversideprops를 사용해야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 getServerSideProps를 사용해야 할까</h3>\n<p>요청 시 반드시 데이터를 가져와야하는 페이지를 렌더링하는 경우에만 <code class=\"language-text\">getServerSideProps</code> 를 사용해야 한다.\n<code class=\"language-text\">getServerSideProps</code>를 사용하는 페이지는 요청 시 서버 측에서 렌더링되며 cache-control 헤더가 구성된 경우에만 캐싱된다.</p>\n<p>만약 요청 동안에 데이터를 렌더링할 필요가 없다면, 클라이언트 사이드 또는 <code class=\"language-text\">getStaticProps</code> 를 통해 데이터를 가져오는 것을\n고려해야 한다.</p>\n<h2 id=\"getserversideprops-or-api-routes\" style=\"position:relative;\"><a href=\"#getserversideprops-or-api-routes\" aria-label=\"getserversideprops or api routes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>getServerSideProps or API Routes</h2>\n<p>서버에서 데이터를 가져오는 것을 원한다면 <a href=\"https://nextjs.org/docs/api-routes/introduction\">API Route</a>에 도달한 다음 <code class=\"language-text\">getServerSideProps</code>에서 해당 API를 호출하고 싶을 수도 있다.\n그것은 서버에서 실행 중인 <code class=\"language-text\">getServerSideProps</code>와 API Routes로 인해 추가적인 request를 발생시키기 때문에 이는 불필요하고 비효율적인 접근이다.</p>\n<p>이어지는 예제를 보면, API route는 CMS로부터 데이터를 가져오는 데 사용된다. 그러면 API route는 <code class=\"language-text\">getServerSideProps</code>로부터 직접 호출된다.\n이렇게 하면 추가 호출이 발생하여 성능이 저하된다. 대신에 <code class=\"language-text\">getServerSideProps</code> 내부로 API Route에서 사용되는 로직을 import하면 된다.\n이것은 CMS, 데이터베이스 또는 다른 API를 <code class=\"language-text\">getServerSideProps</code> 안에서 직접 호출하는 것을 의미한다.</p>\n<h2 id=\"getserversideprops-with-edge-api-routes\" style=\"position:relative;\"><a href=\"#getserversideprops-with-edge-api-routes\" aria-label=\"getserversideprops with edge api routes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>getServerSideProps with Edge API Routes</h2>\n<p><code class=\"language-text\">getServerSideProps</code>는 Serverless 및 Edge Runtimes에서 사용될 수 있으며 둘 다 props를 설정할 수 있다.\n그러나, 현재 Edge Runtime은 reponse 객체에 접근 권한이 없다. 즉 예를 들어 <code class=\"language-text\">getSErverSideProps</code>에서 쿠키를 추가할 수 없다는 의미이다.\nresponse 객체에 접근 권한을 갖기 위해서는 기본 런타임인 Node.js 런타임 환경을 계속 사용해야 한다.</p>\n<p>예처럼, config 파일을 수정하여 per-page basis를 위한 runtime을 명시적으로 세팅할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">runtime</span><span class=\"token operator\">:</span> <span class=\"token string\">'nodejs'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"fetching-data-on-the-client-side\" style=\"position:relative;\"><a href=\"#fetching-data-on-the-client-side\" aria-label=\"fetching data on the client side permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fetching data on the client side</h2>\n<p>자주 업데이트 되는 데이터를 포함하는 페이지라면 데이터를 사전에 렌더링할 필요없이 client side에서 데이터를 가져올 수 있다.\n사용자 상세 데이터를 예로 들어본다면</p>\n<ul>\n<li>첫째, 데이터 없이 즉시 페이지를 보여준다. 페이지 일부는 Static Generation을 사용하여 사전에 렌더링될 수 있다. 누락된 데이터의 로딩 상태를 보여줄 수 있다.</li>\n<li>그리고 client side에서 데이터를 가져오고 준비되었을 때 보여준다.</li>\n</ul>\n<p>이것은 예를 들어 사용자의 대시보드 페이지에 적합하다. 왜냐하면 대시보드는 private하고 사용자의 상세 페이지이며 SEO와 관련이 없기 때문에 사전 렌더링이 필요하지 않다.\n데이터는 자주 업데이트되므로 요청 시 가져와야 한다.</p>\n<h2 id=\"using-getserversideprops-to-fetch-data-at-request-time\" style=\"position:relative;\"><a href=\"#using-getserversideprops-to-fetch-data-at-request-time\" aria-label=\"using getserversideprops to fetch data at request time permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using getServerSideProps to fetch data at request time</h2>\n<p>아래 예제는 request time에 어떻게 데이터를 가져오고 결과를 사전에 렌더링 하는지 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Page</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getServerSideProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Page</code></pre></div>\n<h2 id=\"caching-with-server-side-rendering-ssr\" style=\"position:relative;\"><a href=\"#caching-with-server-side-rendering-ssr\" aria-label=\"caching with server side rendering ssr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caching with Server-Side Rendering (SSR)</h2>\n<p>동적 응답을 캐싱하기 위해 <code class=\"language-text\">getServerSideProps</code> 안의 caching headers(<code class=\"language-text\">Cache-Control</code>)을 사용할 수 있다. 예를 들어, <code class=\"language-text\">stale-while-revalidate</code>를 사용해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getServerSideProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> req<span class=\"token punctuation\">,</span> res <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">'Cache-Control'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'public, s-maxage=10, stale-while-revalidate=59'</span>\n    <span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"does-getserversideprops-render-an-error-page\" style=\"position:relative;\"><a href=\"#does-getserversideprops-render-an-error-page\" aria-label=\"does getserversideprops render an error page permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Does getServerSideProps render an error page</h2>\n<p>만약 <code class=\"language-text\">getServerSideProps</code> 내부에 에러가 있다면 <code class=\"language-text\">pages/500.js</code> 파일을 보여줄 것이다.\n이것을 어떻게 만드는지에 대해 자세한 내용은 <a href=\"https://nextjs.org/docs/advanced-features/custom-error-page#500-page\">500 page</a> 문서를 확인해보면 된다.\n개발하는 동안에는 이 파일이 사용되지 않고 dev overlay 가 대신 보여진다.</p>","frontmatter":{"date":"February 15, 2023","title":"Next.js 공식문서 번역","categories":"TIL","author":"지걸","emoji":"📚"},"fields":{"slug":"/next-js/"}},"site":{"siteMetadata":{"siteUrl":"https://jiyaaany.netlify.app","comments":{"utterances":{"repo":"jiyaaany/jiyaaany.github.io"}}}}},"pageContext":{"slug":"/css-wiki/","nextSlug":"/js-wiki/","prevSlug":"/next-js/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}